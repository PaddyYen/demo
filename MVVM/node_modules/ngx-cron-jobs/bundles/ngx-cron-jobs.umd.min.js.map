{"version":3,"file":"ngx-cron-jobs.umd.min.js","sources":["../../../node_modules/tslib/tslib.es6.js","../../../node_modules/rxjs/src/internal/util/tryCatch.ts","../../../node_modules/rxjs/src/internal/util/isFunction.ts","../../../node_modules/rxjs/src/internal/util/hostReportError.ts","../../../node_modules/rxjs/src/internal/util/isObject.ts","../../../node_modules/rxjs/src/internal/Subscription.ts","../../../node_modules/rxjs/src/internal/Subscriber.ts","../../../node_modules/rxjs/src/internal/Observable.ts","../../../node_modules/rxjs/src/internal/util/subscribeToResult.ts","../../../node_modules/rxjs/src/internal/operators/bufferTime.ts","../../../node_modules/rxjs/src/internal/observable/fromArray.ts","../../../node_modules/rxjs/src/internal/observable/empty.ts","../../../node_modules/rxjs/src/internal/observable/of.ts","../../../node_modules/rxjs/src/internal/util/isScheduler.ts","../../../node_modules/rxjs/src/internal/observable/scalar.ts","../../../node_modules/rxjs/src/internal/operators/map.ts","../../../node_modules/rxjs/src/internal/observable/throwError.ts","../../../node_modules/rxjs/src/internal/operators/refCount.ts","../../../node_modules/rxjs/src/internal/operators/publishReplay.ts","../../../node_modules/rxjs/src/internal/operators/multicast.ts","../../../node_modules/rxjs/src/internal/operators/sampleTime.ts","../../../node_modules/rxjs/src/internal/operators/takeUntil.ts","../../../node_modules/rxjs/src/internal/operators/windowTime.ts","../../../node_modules/rxjs/src/internal/config.ts","../../../node_modules/rxjs/src/internal/Observer.ts","../../../node_modules/rxjs/src/internal/util/UnsubscriptionError.ts","../../../node_modules/rxjs/src/internal/symbol/rxSubscriber.ts","../../../node_modules/rxjs/src/internal/OuterSubscriber.ts","../../../node_modules/rxjs/src/internal/InnerSubscriber.ts","../../../node_modules/rxjs/src/internal/util/toSubscriber.ts","../../../node_modules/rxjs/src/internal/util/pipe.ts","../../../node_modules/rxjs/src/internal/util/subscribeToArray.ts","../../../node_modules/rxjs/src/internal/symbol/iterator.ts","../../../node_modules/rxjs/src/internal/util/subscribeTo.ts","../../../node_modules/rxjs/src/internal/util/subscribeToObservable.ts","../../../node_modules/rxjs/src/internal/util/isPromise.ts","../../../node_modules/rxjs/src/internal/util/subscribeToPromise.ts","../../../node_modules/rxjs/src/internal/util/subscribeToIterable.ts","../../../node_modules/rxjs/src/internal/scheduler/AsyncAction.ts","../../../node_modules/rxjs/src/internal/operators/audit.ts","../../../node_modules/rxjs/src/internal/scheduler/Action.ts","../../../node_modules/rxjs/src/internal/Scheduler.ts","../../../node_modules/rxjs/src/internal/scheduler/AsyncScheduler.ts","../../../node_modules/rxjs/src/internal/scheduler/async.ts","../../../node_modules/rxjs/src/internal/operators/buffer.ts","../../../node_modules/rxjs/src/internal/operators/bufferCount.ts","../../../node_modules/rxjs/src/internal/observable/combineLatest.ts","../../../node_modules/rxjs/src/internal/operators/bufferToggle.ts","../../../node_modules/rxjs/src/internal/operators/bufferWhen.ts","../../../node_modules/rxjs/src/internal/operators/catchError.ts","../../../node_modules/rxjs/src/internal/Notification.ts","../../../node_modules/rxjs/src/internal/operators/mergeMap.ts","../../../node_modules/rxjs/src/internal/operators/count.ts","../../../node_modules/rxjs/src/internal/operators/debounce.ts","../../../node_modules/rxjs/src/internal/operators/debounceTime.ts","../../../node_modules/rxjs/src/internal/operators/defaultIfEmpty.ts","../../../node_modules/rxjs/src/internal/operators/delay.ts","../../../node_modules/rxjs/src/internal/operators/delayWhen.ts","../../../node_modules/rxjs/src/internal/operators/filter.ts","../../../node_modules/rxjs/src/internal/operators/dematerialize.ts","../../../node_modules/rxjs/src/internal/operators/distinct.ts","../../../node_modules/rxjs/src/internal/operators/distinctUntilChanged.ts","../../../node_modules/rxjs/src/internal/util/ArgumentOutOfRangeError.ts","../../../node_modules/rxjs/src/internal/util/EmptyError.ts","../../../node_modules/rxjs/src/internal/operators/tap.ts","../../../node_modules/rxjs/src/internal/util/ObjectUnsubscribedError.ts","../../../node_modules/rxjs/src/internal/operators/take.ts","../../../node_modules/rxjs/src/internal/operators/every.ts","../../../node_modules/rxjs/src/internal/operators/exhaust.ts","../../../node_modules/rxjs/src/internal/operators/exhaustMap.ts","../../../node_modules/rxjs/src/internal/operators/expand.ts","../../../node_modules/rxjs/src/internal/operators/finalize.ts","../../../node_modules/rxjs/src/internal/operators/find.ts","../../../node_modules/rxjs/src/internal/SubjectSubscription.ts","../../../node_modules/rxjs/src/internal/Subject.ts","../../../node_modules/rxjs/src/internal/operators/groupBy.ts","../../../node_modules/rxjs/src/internal/operators/ignoreElements.ts","../../../node_modules/rxjs/src/internal/operators/isEmpty.ts","../../../node_modules/rxjs/src/internal/operators/takeLast.ts","../../../node_modules/rxjs/src/internal/operators/mapTo.ts","../../../node_modules/rxjs/src/internal/operators/materialize.ts","../../../node_modules/rxjs/src/internal/operators/scan.ts","../../../node_modules/rxjs/src/internal/operators/mergeScan.ts","../../../node_modules/rxjs/src/internal/observable/ConnectableObservable.ts","../../../node_modules/rxjs/src/internal/operators/observeOn.ts","../../../node_modules/rxjs/src/internal/scheduler/QueueAction.ts","../../../node_modules/rxjs/src/internal/operators/onErrorResumeNext.ts","../../../node_modules/rxjs/src/internal/operators/pairwise.ts","../../../node_modules/rxjs/src/internal/BehaviorSubject.ts","../../../node_modules/rxjs/src/internal/AsyncSubject.ts","../../../node_modules/rxjs/src/internal/scheduler/queue.ts","../../../node_modules/rxjs/src/internal/scheduler/QueueScheduler.ts","../../../node_modules/rxjs/src/internal/ReplaySubject.ts","../../../node_modules/rxjs/src/internal/operators/sequenceEqual.ts","../../../node_modules/rxjs/src/internal/observable/race.ts","../../../node_modules/rxjs/src/internal/operators/repeat.ts","../../../node_modules/rxjs/src/internal/operators/repeatWhen.ts","../../../node_modules/rxjs/src/internal/operators/retry.ts","../../../node_modules/rxjs/src/internal/operators/retryWhen.ts","../../../node_modules/rxjs/src/internal/operators/sample.ts","../../../node_modules/rxjs/src/internal/util/Immediate.ts","../../../node_modules/rxjs/src/internal/operators/single.ts","../../../node_modules/rxjs/src/internal/operators/skip.ts","../../../node_modules/rxjs/src/internal/operators/skipLast.ts","../../../node_modules/rxjs/src/internal/operators/skipUntil.ts","../../../node_modules/rxjs/src/internal/operators/skipWhile.ts","../../../node_modules/rxjs/src/internal/scheduler/AsapAction.ts","../../../node_modules/rxjs/src/internal/scheduler/asap.ts","../../../node_modules/rxjs/src/internal/scheduler/AsapScheduler.ts","../../../node_modules/rxjs/src/internal/observable/SubscribeOnObservable.ts","../../../node_modules/rxjs/src/internal/util/isNumeric.ts","../../../node_modules/rxjs/src/internal/operators/switchMap.ts","../../../node_modules/rxjs/src/internal/operators/takeWhile.ts","../../../node_modules/rxjs/src/internal/operators/throttle.ts","../../../node_modules/rxjs/src/internal/operators/throttleTime.ts","../../../node_modules/rxjs/src/internal/util/TimeoutError.ts","../../../node_modules/rxjs/src/internal/operators/timeoutWith.ts","../../../node_modules/rxjs/src/internal/operators/window.ts","../../../node_modules/rxjs/src/internal/operators/windowCount.ts","../../../node_modules/rxjs/src/internal/observable/zip.ts","../../../node_modules/rxjs/src/internal/operators/windowToggle.ts","../../../node_modules/rxjs/src/internal/operators/windowWhen.ts","../../../node_modules/rxjs/src/internal/operators/withLatestFrom.ts","~/ngx-cron-jobs/src/app/lib/contracts/contracts.ts","~/ngx-cron-jobs/src/app/lib/services/data.service.ts","../../../node_modules/rxjs/src/internal/scheduler/AnimationFrameAction.ts","../../../node_modules/rxjs/src/internal/scheduler/VirtualTimeScheduler.ts","../../../node_modules/rxjs/src/internal/scheduler/animationFrame.ts","../../../node_modules/rxjs/src/internal/scheduler/AnimationFrameScheduler.ts","~/ngx-cron-jobs/src/app/lib/services/posix.service.ts","../../../node_modules/rxjs/src/internal/observable/forkJoin.ts","~/ngx-cron-jobs/src/app/lib/services/quartz.service.ts","~/ngx-cron-jobs/src/app/lib/cron-jobs/cron-jobs.component.ts","~/ngx-cron-jobs/src/app/lib/cron-jobs.module.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { errorObject } from './errorObject';\n\nlet tryCatchTarget: Function;\n\nfunction tryCatcher(this: any): any {\n  try {\n    return tryCatchTarget.apply(this, arguments);\n  } catch (e) {\n    errorObject.e = e;\n    return errorObject;\n  }\n}\n\nexport function tryCatch<T extends Function>(fn: T): T {\n  tryCatchTarget = fn;\n  return <any>tryCatcher;\n}\n","export function isFunction(x: any): x is Function {\n  return typeof x === 'function';\n}\n","/**\n * Throws an error on another job so that it's picked up by the runtime's\n * uncaught error handling mechanism.\n * @param err the error to throw\n */\nexport function hostReportError(err: any) {\n  setTimeout(() => { throw err; });\n}","export function isObject(x: any): x is Object {\n  return x != null && typeof x === 'object';\n}\n","import { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { tryCatch } from './util/tryCatch';\nimport { errorObject } from './util/errorObject';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic } from './types';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements SubscriptionLike {\n  /** @nocollapse */\n  public static EMPTY: Subscription = (function(empty: any) {\n    empty.closed = true;\n    return empty;\n  }(new Subscription()));\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   * @type {boolean}\n   */\n  public closed: boolean = false;\n\n  /** @internal */\n  protected _parent: Subscription = null;\n  /** @internal */\n  protected _parents: Subscription[] = null;\n  /** @internal */\n  private _subscriptions: SubscriptionLike[] = null;\n\n  /**\n   * @param {function(): void} [unsubscribe] A function describing how to\n   * perform the disposal of resources when the `unsubscribe` method is called.\n   */\n  constructor(unsubscribe?: () => void) {\n    if (unsubscribe) {\n      (<any> this)._unsubscribe = unsubscribe;\n\n    }\n  }\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let hasErrors = false;\n    let errors: any[];\n\n    if (this.closed) {\n      return;\n    }\n\n    let { _parent, _parents, _unsubscribe, _subscriptions } = (<any> this);\n\n    this.closed = true;\n    this._parent = null;\n    this._parents = null;\n    // null out _subscriptions first so any child subscriptions that attempt\n    // to remove themselves from this subscription will noop\n    this._subscriptions = null;\n\n    let index = -1;\n    let len = _parents ? _parents.length : 0;\n\n    // if this._parent is null, then so is this._parents, and we\n    // don't have to remove ourselves from any parent subscriptions.\n    while (_parent) {\n      _parent.remove(this);\n      // if this._parents is null or index >= len,\n      // then _parent is set to null, and the loop exits\n      _parent = ++index < len && _parents[index] || null;\n    }\n\n    if (isFunction(_unsubscribe)) {\n      let trial = tryCatch(_unsubscribe).call(this);\n      if (trial === errorObject) {\n        hasErrors = true;\n        errors = errors || (\n          errorObject.e instanceof UnsubscriptionError ?\n            flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]\n        );\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n\n      index = -1;\n      len = _subscriptions.length;\n\n      while (++index < len) {\n        const sub = _subscriptions[index];\n        if (isObject(sub)) {\n          let trial = tryCatch(sub.unsubscribe).call(sub);\n          if (trial === errorObject) {\n            hasErrors = true;\n            errors = errors || [];\n            let err = errorObject.e;\n            if (err instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new UnsubscriptionError(errors);\n    }\n  }\n\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this\n   * Subscription.\n   *\n   * If the tear down being added is a subscription that is already\n   * unsubscribed, is the same reference `add` is being called on, or is\n   * `Subscription.EMPTY`, it will not be added.\n   *\n   * If this subscription is already in an `closed` state, the passed\n   * tear down logic will be executed immediately.\n   *\n   * @param {TeardownLogic} teardown The additional logic to execute on\n   * teardown.\n   * @return {Subscription} Returns the Subscription used or created to be\n   * added to the inner subscriptions list. This Subscription can be used with\n   * `remove()` to remove the passed teardown logic from the inner subscriptions\n   * list.\n   */\n  add(teardown: TeardownLogic): Subscription {\n    if (!teardown || (teardown === Subscription.EMPTY)) {\n      return Subscription.EMPTY;\n    }\n\n    if (teardown === this) {\n      return this;\n    }\n\n    let subscription = (<Subscription> teardown);\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(<(() => void) > teardown);\n      case 'object':\n        if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n          const tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n        break;\n      default:\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n    }\n\n    const subscriptions = this._subscriptions || (this._subscriptions = []);\n\n    subscriptions.push(subscription);\n    subscription._addParent(this);\n\n    return subscription;\n  }\n\n  /**\n   * Removes a Subscription from the internal list of subscriptions that will\n   * unsubscribe during the unsubscribe process of this Subscription.\n   * @param {Subscription} subscription The subscription to remove.\n   * @return {void}\n   */\n  remove(subscription: Subscription): void {\n    const subscriptions = this._subscriptions;\n    if (subscriptions) {\n      const subscriptionIndex = subscriptions.indexOf(subscription);\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  }\n\n  /** @internal */\n  private _addParent(parent: Subscription) {\n    let { _parent, _parents } = this;\n    if (!_parent || _parent === parent) {\n      // If we don't have a parent, or the new parent is the same as the\n      // current parent, then set this._parent to the new parent.\n      this._parent = parent;\n    } else if (!_parents) {\n      // If there's already one parent, but not multiple, allocate an Array to\n      // store the rest of the parent Subscriptions.\n      this._parents = [parent];\n    } else if (_parents.indexOf(parent) === -1) {\n      // Only add the new parent to the _parents list if it's not already there.\n      _parents.push(parent);\n    }\n  }\n}\n\nfunction flattenUnsubscriptionErrors(errors: any[]) {\n return errors.reduce((errs, err) => errs.concat((err instanceof UnsubscriptionError) ? err.errors : err), []);\n}\n","import { isFunction } from './util/isFunction';\nimport { empty as emptyObserver } from './Observer';\nimport { Observer, PartialObserver } from './types';\nimport { Subscription } from './Subscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n\n  [rxSubscriberSymbol]() { return this; }\n\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   */\n  static create<T>(next?: (x?: T) => void,\n                   error?: (e?: any) => void,\n                   complete?: () => void): Subscriber<T> {\n    const subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  }\n\n  /** @internal */ syncErrorValue: any = null;\n  /** @internal */ syncErrorThrown: boolean = false;\n  /** @internal */ syncErrorThrowable: boolean = false;\n\n  protected isStopped: boolean = false;\n  protected destination: PartialObserver<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = emptyObserver;\n        break;\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = emptyObserver;\n          break;\n        }\n        if (typeof destinationOrNext === 'object') {\n          // HACK(benlesh): For situations where Node has multiple copies of rxjs in\n          // node_modules, we cannot rely on `instanceof` checks\n          if (isTrustedSubscriber(destinationOrNext)) {\n            const trustedSubscriber = destinationOrNext[rxSubscriberSymbol]() as Subscriber<any>;\n            this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;\n            this.destination = trustedSubscriber;\n            trustedSubscriber.add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);\n          }\n          break;\n        }\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached {@link Error}. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.closed) {\n      return;\n    }\n    this.isStopped = true;\n    super.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.destination.complete();\n    this.unsubscribe();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribeAndRecycle(): Subscriber<T> {\n    const { _parent, _parents } = this;\n    this._parent = null;\n    this._parents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parent = _parent;\n    this._parents = _parents;\n    return this;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SafeSubscriber<T> extends Subscriber<T> {\n\n  private _context: any;\n\n  constructor(private _parentSubscriber: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    let next: ((value: T) => void);\n    let context: any = this;\n\n    if (isFunction(observerOrNext)) {\n      next = (<((value: T) => void)> observerOrNext);\n    } else if (observerOrNext) {\n      next = (<PartialObserver<T>> observerOrNext).next;\n      error = (<PartialObserver<T>> observerOrNext).error;\n      complete = (<PartialObserver<T>> observerOrNext).complete;\n      if (observerOrNext !== emptyObserver) {\n        context = Object.create(observerOrNext);\n        if (isFunction(context.unsubscribe)) {\n          this.add(<() => void> context.unsubscribe.bind(context));\n        }\n        context.unsubscribe = this.unsubscribe.bind(this);\n      }\n    }\n\n    this._context = context;\n    this._next = next;\n    this._error = error;\n    this._complete = complete;\n  }\n\n  next(value?: T): void {\n    if (!this.isStopped && this._next) {\n      const { _parentSubscriber } = this;\n      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  error(err?: any): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      const { useDeprecatedSynchronousErrorHandling } = config;\n      if (this._error) {\n        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n        if (useDeprecatedSynchronousErrorHandling) {\n          throw err;\n        }\n        hostReportError(err);\n      } else {\n        if (useDeprecatedSynchronousErrorHandling) {\n          _parentSubscriber.syncErrorValue = err;\n          _parentSubscriber.syncErrorThrown = true;\n        } else {\n          hostReportError(err);\n        }\n        this.unsubscribe();\n      }\n    }\n  }\n\n  complete(): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._complete) {\n        const wrappedComplete = () => this._complete.call(this._context);\n\n        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  private __tryOrUnsub(fn: Function, value?: any): void {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        throw err;\n      } else {\n        hostReportError(err);\n      }\n    }\n  }\n\n  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean {\n    if (!config.useDeprecatedSynchronousErrorHandling) {\n      throw new Error('bad call');\n    }\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        parent.syncErrorValue = err;\n        parent.syncErrorThrown = true;\n        return true;\n      } else {\n        hostReportError(err);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe(): void {\n    const { _parentSubscriber } = this;\n    this._context = null;\n    this._parentSubscriber = null;\n    _parentSubscriber.unsubscribe();\n  }\n}\n\nfunction isTrustedSubscriber(obj: any) {\n  return obj instanceof Subscriber || ('syncErrorThrowable' in obj && obj[rxSubscriberSymbol]);\n}\n","import { Operator } from './Operator';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, PartialObserver, Subscribable } from './types';\nimport { toSubscriber } from './util/toSubscriber';\nimport { iif } from './observable/iif';\nimport { throwError } from './observable/throwError';\nimport { observable as Symbol_observable } from '../internal/symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n\n  /** Internal implementation detail, do not use directly. */\n  public _isScalar: boolean = false;\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  source: Observable<any>;\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  operator: Operator<any, T>;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new cold Observable by calling the Observable constructor\n   * @static true\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new cold observable\n   * @nocollapse\n   */\n  static create: Function = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  }\n\n  /**\n   * Creates a new Observable, with this Observable as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param {Operator} operator the operator defining the operation to take on the observable\n   * @return {Observable} a new observable with the Operator applied\n   */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observer?: PartialObserver<T>): Subscription;\n  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to a {@link create} static factory, but most of the time it is\n   * a library implementation, which defines what and when will be emitted by an Observable. This means that calling\n   * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will\n   * be left uncaught.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent\n   * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,\n   * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n   *\n   * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.\n   *\n   * ## Example\n   * ### Subscribe with an Observer\n   * ```javascript\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() { // We actually could just remove this method,\n   *   },        // since we do not really care about errors right now.\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   * .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   * ```\n   *\n   * ### Subscribe with functions\n   * ```javascript\n   * let sum = 0;\n   *\n   * Rx.Observable.of(1, 2, 3)\n   * .subscribe(\n   *   function(value) {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   function() {\n   *     console.log('Sum equals: ' + sum);\n   *   }\n   * );\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   * ```\n   *\n   * ### Cancel a subscription\n   * ```javascript\n   * const subscription = Rx.Observable.interval(1000).subscribe(\n   *   num => console.log(num),\n   *   undefined,\n   *   () => console.log('completed!') // Will not be called, even\n   * );                                // when cancelling subscription\n   *\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // \"unsubscribed!\" after 2.5s\n   * ```\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   *  Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   *  the error will be thrown as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {ISubscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): Subscription {\n\n    const { operator } = this;\n    const sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      operator.call(sink, this.source);\n    } else {\n      sink.add(\n        this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?\n        this._subscribe(sink) :\n        this._trySubscribe(sink)\n      );\n    }\n\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      if (sink.syncErrorThrowable) {\n        sink.syncErrorThrowable = false;\n        if (sink.syncErrorThrown) {\n          throw sink.syncErrorValue;\n        }\n      }\n    }\n\n    return sink;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        sink.syncErrorThrown = true;\n        sink.syncErrorValue = err;\n      }\n      sink.error(err);\n    }\n  }\n\n  /**\n   * @method forEach\n   * @param {Function} next a handler for each value emitted by the observable\n   * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise\n   * @return {Promise} a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      // Must be declared in a separate statement to avoid a RefernceError when\n      // accessing subscription below in the closure due to Temporal Dead Zone.\n      let subscription: Subscription;\n      subscription = this.subscribe((value) => {\n        try {\n          next(value);\n        } catch (err) {\n          reject(err);\n          if (subscription) {\n            subscription.unsubscribe();\n          }\n        }\n      }, reject, resolve);\n    }) as Promise<void>;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    const { source } = this;\n    return source && source.subscribe(subscriber);\n  }\n\n  // `if` and `throw` are special snow flakes, the compiler sees them as reserved words. Deprecated in\n  // favor of iif and throwError functions.\n  /**\n   * @nocollapse\n   * @deprecated In favor of iif creation function: import { iif } from 'rxjs';\n   */\n  static if: typeof iif;\n  /**\n   * @nocollapse\n   * @deprecated In favor of throwError creation function: import { throwError } from 'rxjs';\n   */\n  static throw: typeof throwError;\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>;\n  pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>;\n  pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): Observable<I>;\n  pipe<R>(...operations: OperatorFunction<any, any>[]): Observable<R>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * ### Example\n   * ```javascript\n   * import { map, filter, scan } from 'rxjs/operators';\n   *\n   * Rx.Observable.interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x))\n   * ```\n   */\n  pipe<R>(...operations: OperatorFunction<T, R>[]): Observable<R> {\n    if (operations.length === 0) {\n      return this as any;\n    }\n\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  toPromise<T>(this: Observable<T>): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: typeof Promise): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: PromiseConstructorLike): Promise<T>;\n  /* tslint:enable:max-line-length */\n\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: any;\n      this.subscribe((x: T) => value = x, (err: any) => reject(err), () => resolve(value));\n    }) as Promise<T>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  if (!promiseCtor) {\n    promiseCtor = config.Promise || Promise;\n  }\n\n  if (!promiseCtor) {\n    throw new Error('no Promise impl found');\n  }\n\n  return promiseCtor;\n}\n","\nimport { ObservableInput } from '../types';\nimport { Subscription } from '../Subscription';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeTo } from './subscribeTo';\n\nexport function subscribeToResult<T, R>(outerSubscriber: OuterSubscriber<T, R>,\n                                        result: any,\n                                        outerValue?: T,\n                                        outerIndex?: number): Subscription;\nexport function subscribeToResult<T>(outerSubscriber: OuterSubscriber<any, any>,\n                                     result: ObservableInput<T>,\n                                     outerValue?: T,\n                                     outerIndex?: number): Subscription | void {\n  const destination = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n\n  return subscribeTo(result)(destination);\n}\n","import { Operator } from '../Operator';\nimport { async } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { isScheduler } from '../util/isScheduler';\nimport { OperatorFunction, SchedulerAction, SchedulerLike } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function bufferTime<T>(bufferTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(bufferTimeSpan: number, bufferCreationInterval: number | null | undefined, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(bufferTimeSpan: number, bufferCreationInterval: number | null | undefined, maxBufferSize: number, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\n/* tslint:enable:max-line-length */\n\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * ## Examples\n *\n * Every second, emit an array of the recent click events\n *\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(1000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds, emit the click events from the next 2 seconds\n *\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(2000, 5000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\nexport function bufferTime<T>(bufferTimeSpan: number): OperatorFunction<T, T[]> {\n  let length: number = arguments.length;\n\n  let scheduler: SchedulerLike = async;\n  if (isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n\n  let bufferCreationInterval: number = null;\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n\n  let maxBufferSize: number = Number.POSITIVE_INFINITY;\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n\n  return function bufferTimeOperatorFunction(source: Observable<T>) {\n    return source.lift(new BufferTimeOperator<T>(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n  };\n}\n\nclass BufferTimeOperator<T> implements Operator<T, T[]> {\n  constructor(private bufferTimeSpan: number,\n              private bufferCreationInterval: number,\n              private maxBufferSize: number,\n              private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): any {\n    return source.subscribe(new BufferTimeSubscriber(\n      subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler\n    ));\n  }\n}\n\nclass Context<T> {\n  buffer: T[] = [];\n  closeAction: Subscription;\n}\n\ninterface DispatchCreateArg<T> {\n  bufferTimeSpan: number;\n  bufferCreationInterval: number;\n  subscriber: BufferTimeSubscriber<T>;\n  scheduler: SchedulerLike;\n}\n\ninterface DispatchCloseArg<T> {\n  subscriber: BufferTimeSubscriber<T>;\n  context: Context<T>;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferTimeSubscriber<T> extends Subscriber<T> {\n  private contexts: Array<Context<T>> = [];\n  private timespanOnly: boolean;\n\n  constructor(destination: Subscriber<T[]>,\n              private bufferTimeSpan: number,\n              private bufferCreationInterval: number,\n              private maxBufferSize: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n    const context = this.openContext();\n    this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n    if (this.timespanOnly) {\n      const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    } else {\n      const closeState = { subscriber: this, context };\n      const creationState: DispatchCreateArg<T> = { bufferTimeSpan, bufferCreationInterval, subscriber: this, scheduler };\n      this.add(context.closeAction = scheduler.schedule<DispatchCloseArg<T>>(dispatchBufferClose, bufferTimeSpan, closeState));\n      this.add(scheduler.schedule<DispatchCreateArg<T>>(dispatchBufferCreation, bufferCreationInterval, creationState));\n    }\n  }\n\n  protected _next(value: T) {\n    const contexts = this.contexts;\n    const len = contexts.length;\n    let filledBufferContext: Context<T>;\n    for (let i = 0; i < len; i++) {\n      const context = contexts[i];\n      const buffer = context.buffer;\n      buffer.push(value);\n      if (buffer.length == this.maxBufferSize) {\n        filledBufferContext = context;\n      }\n    }\n\n    if (filledBufferContext) {\n      this.onBufferFull(filledBufferContext);\n    }\n  }\n\n  protected _error(err: any) {\n    this.contexts.length = 0;\n    super._error(err);\n  }\n\n  protected _complete() {\n    const { contexts, destination } = this;\n    while (contexts.length > 0) {\n      const context = contexts.shift();\n      destination.next(context.buffer);\n    }\n    super._complete();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    this.contexts = null;\n  }\n\n  protected onBufferFull(context: Context<T>) {\n    this.closeContext(context);\n    const closeAction = context.closeAction;\n    closeAction.unsubscribe();\n    this.remove(closeAction);\n\n    if (!this.closed && this.timespanOnly) {\n      context = this.openContext();\n      const bufferTimeSpan = this.bufferTimeSpan;\n      const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    }\n  }\n\n  openContext(): Context<T> {\n    const context: Context<T> = new Context<T>();\n    this.contexts.push(context);\n    return context;\n  }\n\n  closeContext(context: Context<T>) {\n    this.destination.next(context.buffer);\n    const contexts = this.contexts;\n\n    const spliceIndex = contexts ? contexts.indexOf(context) : -1;\n    if (spliceIndex >= 0) {\n      contexts.splice(contexts.indexOf(context), 1);\n    }\n  }\n}\n\nfunction dispatchBufferTimeSpanOnly(this: SchedulerAction<any>, state: any) {\n  const subscriber: BufferTimeSubscriber<any> = state.subscriber;\n\n  const prevContext = state.context;\n  if (prevContext) {\n    subscriber.closeContext(prevContext);\n  }\n\n  if (!subscriber.closed) {\n    state.context = subscriber.openContext();\n    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n  }\n}\n\nfunction dispatchBufferCreation<T>(this: SchedulerAction<DispatchCreateArg<T>>, state: DispatchCreateArg<T>) {\n  const { bufferCreationInterval, bufferTimeSpan, subscriber, scheduler } = state;\n  const context = subscriber.openContext();\n  const action = <SchedulerAction<DispatchCreateArg<T>>>this;\n  if (!subscriber.closed) {\n    subscriber.add(context.closeAction = scheduler.schedule<DispatchCloseArg<T>>(dispatchBufferClose, bufferTimeSpan, { subscriber, context }));\n    action.schedule(state, bufferCreationInterval);\n  }\n}\n\nfunction dispatchBufferClose<T>(arg: DispatchCloseArg<T>) {\n  const { subscriber, context } = arg;\n  subscriber.closeContext(context);\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { Subscription } from '../Subscription';\nimport { subscribeToArray } from '../util/subscribeToArray';\n\nexport function fromArray<T>(input: ArrayLike<T>, scheduler?: SchedulerLike) {\n  if (!scheduler) {\n    return new Observable<T>(subscribeToArray(input));\n  } else {\n    return new Observable<T>(subscriber => {\n      const sub = new Subscription();\n      let i = 0;\n      sub.add(scheduler.schedule(function () {\n        if (i === input.length) {\n          subscriber.complete();\n          return;\n        }\n        subscriber.next(input[i++]);\n        if (!subscriber.closed) {\n          sub.add(this.schedule());\n        }\n      }));\n      return sub;\n    });\n  }\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\n/**\n * The same Observable instance returned by any call to {@link empty} without a\n * {@link Scheduler}. It is preferrable to use this over `empty()`.\n */\nexport const EMPTY = new Observable<never>(subscriber => subscriber.complete());\n\n/**\n * Creates an Observable that emits no items to the Observer and immediately\n * emits a complete notification.\n *\n * <span class=\"informal\">Just emits 'complete', and nothing else.\n * </span>\n *\n * <img src=\"./img/empty.png\" width=\"100%\">\n *\n * This static operator is useful for creating a simple Observable that only\n * emits the complete notification. It can be used for composing with other\n * Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n * ### Emit the number 7, then complete\n * ```javascript\n * const result = empty().pipe(startWith(7));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * ### Map and flatten only odd numbers to the sequence 'a', 'b', 'c'\n * ```javascript\n * const interval$ = interval(1000);\n * result = interval$.pipe(\n *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : empty()),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following to the console:\n * // x is equal to the count on the interval eg(0,1,2,3,...)\n * // x will occur every 1000ms\n * // if x % 2 is equal to 1 print abc\n * // if x % 2 is not equal to 1 nothing will be output\n * ```\n *\n * @see {@link create}\n * @see {@link never}\n * @see {@link of}\n * @see {@link throw}\n *\n * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n * the emission of the complete notification.\n * @return {Observable} An \"empty\" Observable: emits only the complete\n * notification.\n * @static true\n * @name empty\n * @owner Observable\n * @deprecated Deprecated in favor of using EMPTY constant.\n */\nexport function empty(scheduler?: SchedulerLike) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nexport function emptyScheduled(scheduler: SchedulerLike) {\n  return new Observable<never>(subscriber => scheduler.schedule(() => subscriber.complete()));\n}\n","import { SchedulerLike } from '../types';\nimport { isScheduler } from '../util/isScheduler';\nimport { fromArray } from './fromArray';\nimport { empty } from './empty';\nimport { scalar } from './scalar';\nimport { Observable } from '../Observable';\n\nexport function of<T>(a: T, scheduler?: SchedulerLike): Observable<T>;\nexport function of<T, T2>(a: T, b: T2, scheduler?: SchedulerLike): Observable<T | T2>;\nexport function of<T, T2, T3>(a: T, b: T2, c: T3, scheduler?: SchedulerLike): Observable<T | T2 | T3>;\nexport function of<T, T2, T3, T4>(a: T, b: T2, c: T3, d: T4, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4>;\nexport function of<T, T2, T3, T4, T5>(a: T, b: T2, c: T3, d: T4, e: T5, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;\nexport function of<T, T2, T3, T4, T5, T6>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function of<T, T2, T3, T4, T5, T6, T7>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, scheduler?: SchedulerLike):\n  Observable<T | T2 | T3 | T4 | T5 | T6 | T7>;\nexport function of<T, T2, T3, T4, T5, T6, T7, T8>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, scheduler?: SchedulerLike):\n  Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8>;\nexport function of<T, T2, T3, T4, T5, T6, T7, T8, T9>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, i: T9, scheduler?: SchedulerLike):\n  Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>;\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T>;\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T> {\n  let scheduler = args[args.length - 1] as SchedulerLike;\n  if (isScheduler(scheduler)) {\n    args.pop();\n  } else {\n    scheduler = undefined;\n  }\n  switch (args.length) {\n    case 0:\n      return empty(scheduler);\n    case 1:\n      return scheduler ? fromArray(args as T[], scheduler) : scalar(args[0] as T);\n    default:\n      return fromArray(args as T[], scheduler);\n  }\n}\n","import { SchedulerLike } from '../types';\n\nexport function isScheduler(value: any): value is SchedulerLike {\n  return value && typeof (<any>value).schedule === 'function';\n}\n","import { Observable } from '../Observable';\n\nexport function scalar<T>(value: T) {\n  const result = new Observable<T>(subscriber => {\n    subscriber.next(value);\n    subscriber.complete();\n  });\n  result._isScalar = true;\n  (result as any).value = value;\n  return result;\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * ## Example\n * Map every click to the clientX position of that click\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const positions = clicks.pipe(map(ev => ev.clientX));\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\n  return function mapOperation(source: Observable<T>): Observable<R> {\n    if (typeof project !== 'function') {\n      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return source.lift(new MapOperator(project, thisArg));\n  };\n}\n\nexport class MapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => R, private thisArg: any) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MapSubscriber<T, R> extends Subscriber<T> {\n  count: number = 0;\n  private thisArg: any;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => R,\n              thisArg: any) {\n    super(destination);\n    this.thisArg = thisArg || this;\n  }\n\n  // NOTE: This looks unoptimized, but it's actually purposefully NOT\n  // using try/catch optimizations.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.project.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { Subscriber } from '../Subscriber';\n\n/**\n * Creates an Observable that emits no items to the Observer and immediately\n * emits an error notification.\n *\n * <span class=\"informal\">Just emits 'error', and nothing else.\n * </span>\n *\n * <img src=\"./img/throw.png\" width=\"100%\">\n *\n * This static operator is useful for creating a simple Observable that only\n * emits the error notification. It can be used for composing with other\n * Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n * ### Emit the number 7, then emit an error\n * ```javascript\n * import { throwError, concat, of } from 'rxjs';\n *\n * const result = concat(of(7), throwError(new Error('oops!')));\n * result.subscribe(x => console.log(x), e => console.error(e));\n * ```javascript\n *\n * ### Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13\n * ```javascript\n * import { throwError, interval, of } from 'rxjs';\n * import { mergeMap } from 'rxjs/operators';\n *\n * interval(1000).pipe(\n *   mergeMap(x => x === 13\n *     ? throwError('Thirteens are bad')\n *     : of('a', 'b', 'c')\n *   ),\n * ).subscribe(x => console.log(x), e => console.error(e));\n * ```\n * @see {@link create}\n * @see {@link empty}\n * @see {@link never}\n * @see {@link of}\n *\n * @param {any} error The particular Error to pass to the error notification.\n * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n * the emission of the error notification.\n * @return {Observable} An error Observable: emits only the error notification\n * using the given error argument.\n * @static true\n * @name throw\n * @owner Observable\n */\nexport function throwError(error: any, scheduler?: SchedulerLike): Observable<never> {\n  if (!scheduler) {\n    return new Observable(subscriber => subscriber.error(error));\n  } else {\n    return new Observable(subscriber => scheduler.schedule(dispatch, 0, { error, subscriber }));\n  }\n}\n\ninterface DispatchArg {\n  error: any;\n  subscriber: Subscriber<any>;\n}\n\nfunction dispatch({ error, subscriber }: DispatchArg) {\n  subscriber.error(error);\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { Observable } from '../Observable';\n\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\n  return function refCountOperatorFunction(source: ConnectableObservable<T>): Observable<T> {\n    return source.lift(new RefCountOperator(source));\n  } as MonoTypeOperatorFunction<T>;\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  protected _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // range(0, 10).pipe(\n    //   publish(),\n    //   refCount(),\n    //   take(5),\n    // )\n    // .subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { ReplaySubject } from '../ReplaySubject';\nimport { multicast } from './multicast';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction, MonoTypeOperatorFunction, OperatorFunction, SchedulerLike } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function publishReplay<T>(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\nexport function publishReplay<T, R>(bufferSize?: number, windowTime?: number, selector?: OperatorFunction<T, R>, scheduler?: SchedulerLike): OperatorFunction<T, R>;\nexport function publishReplay<T>(bufferSize?: number, windowTime?: number, selector?: MonoTypeOperatorFunction<T>, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\nexport function publishReplay<T, R>(bufferSize?: number,\n                                    windowTime?: number,\n                                    selectorOrScheduler?: SchedulerLike | OperatorFunction<T, R>,\n                                    scheduler?: SchedulerLike): UnaryFunction<Observable<T>, ConnectableObservable<R>> {\n\n  if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {\n    scheduler = selectorOrScheduler;\n  }\n\n  const selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;\n  const subject = new ReplaySubject<T>(bufferSize, windowTime, scheduler);\n\n  return (source: Observable<T>) => multicast(() => subject, selector)(source) as ConnectableObservable<R>;\n}\n","import { Subject } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { ConnectableObservable, connectableObservableDescriptor } from '../observable/ConnectableObservable';\nimport { FactoryOrValue, MonoTypeOperatorFunction, OperatorFunction, UnaryFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function multicast<T>(subjectOrSubjectFactory: FactoryOrValue<Subject<T>>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\nexport function multicast<T>(SubjectFactory: (this: Observable<T>) => Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\nexport function multicast<T>(SubjectFactory: (this: Observable<T>) => Subject<T>, selector?: MonoTypeOperatorFunction<T>): MonoTypeOperatorFunction<T>;\nexport function multicast<T, R>(SubjectFactory: (this: Observable<T>) => Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<R>>;\nexport function multicast<T, R>(SubjectFactory: (this: Observable<T>) => Subject<T>, selector?: OperatorFunction<T, R>): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits the results of invoking a specified selector on items\n * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.\n *\n * <img src=\"./img/multicast.png\" width=\"100%\">\n *\n * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through\n * which the source sequence's elements will be multicast to the selector function\n * or Subject to push source elements into.\n * @param {Function} [selector] - Optional selector function that can use the multicasted source stream\n * as many times as needed, without causing multiple subscriptions to the source stream.\n * Subscribers to the given source will receive all notifications of the source from the\n * time of the subscription forward.\n * @return {Observable} An Observable that emits the results of invoking the selector\n * on the items emitted by a `ConnectableObservable` that shares a single subscription to\n * the underlying stream.\n * @method multicast\n * @owner Observable\n */\nexport function multicast<T, R>(subjectOrSubjectFactory: Subject<T> | (() => Subject<T>),\n                                selector?: (source: Observable<T>) => Observable<R>): OperatorFunction<T, R> {\n  return function multicastOperatorFunction(source: Observable<T>): Observable<R> {\n    let subjectFactory: () => Subject<T>;\n    if (typeof subjectOrSubjectFactory === 'function') {\n      subjectFactory = <() => Subject<T>>subjectOrSubjectFactory;\n    } else {\n      subjectFactory = function subjectFactory() {\n        return <Subject<T>>subjectOrSubjectFactory;\n      };\n    }\n\n    if (typeof selector === 'function') {\n      return source.lift(new MulticastOperator(subjectFactory, selector));\n    }\n\n    const connectable: any = Object.create(source, connectableObservableDescriptor);\n    connectable.source = source;\n    connectable.subjectFactory = subjectFactory;\n\n    return <ConnectableObservable<R>> connectable;\n  };\n}\n\nexport class MulticastOperator<T, R> implements Operator<T, R> {\n  constructor(private subjectFactory: () => Subject<T>,\n              private selector: (source: Observable<T>) => Observable<R>) {\n  }\n  call(subscriber: Subscriber<R>, source: any): any {\n    const { selector } = this;\n    const subject = this.subjectFactory();\n    const subscription = selector(subject).subscribe(subscriber);\n    subscription.add(source.subscribe(subject));\n    return subscription;\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { async } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n * Emits the most recently emitted value from the source Observable within\n * periodic time intervals.\n *\n * <span class=\"informal\">Samples the source Observable at periodic time\n * intervals, emitting what it samples.</span>\n *\n * <img src=\"./img/sampleTime.png\" width=\"100%\">\n *\n * `sampleTime` periodically looks at the source Observable and emits whichever\n * value it has most recently emitted since the previous sampling, unless the\n * source has not emitted anything since the previous sampling. The sampling\n * happens periodically in time every `period` milliseconds (or the time unit\n * defined by the optional `scheduler` argument). The sampling starts as soon as\n * the output Observable is subscribed.\n *\n * ## Example\n * Every second, emit the most recent click at most once\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(sampleTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {number} period The sampling period expressed in milliseconds or the\n * time unit determined internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the sampling.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable at the specified time interval.\n * @method sampleTime\n * @owner Observable\n */\nexport function sampleTime<T>(period: number, scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SampleTimeOperator(period, scheduler));\n}\n\nclass SampleTimeOperator<T> implements Operator<T, T> {\n  constructor(private period: number,\n              private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SampleTimeSubscriber<T> extends Subscriber<T> {\n  lastValue: T;\n  hasValue: boolean = false;\n\n  constructor(destination: Subscriber<T>,\n              private period: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n    this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period }));\n  }\n\n  protected _next(value: T) {\n    this.lastValue = value;\n    this.hasValue = true;\n  }\n\n  notifyNext() {\n    if (this.hasValue) {\n      this.hasValue = false;\n      this.destination.next(this.lastValue);\n    }\n  }\n}\n\nfunction dispatchNotification<T>(this: SchedulerAction<any>, state: any) {\n  let { subscriber, period } = state;\n  subscriber.notifyNext();\n  this.schedule(state, period);\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\n\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits a value. Then, it completes.</span>\n *\n * <img src=\"./img/takeUntil.png\" width=\"100%\">\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value, the output Observable stops mirroring the source Observable\n * and completes. If the `notifier` doesn't emit any value and completes\n * then `takeUntil` will pass all values.\n *\n * ## Example\n * Tick every second until the first click happens\n * ```javascript\n * const interval = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = interval.pipe(takeUntil(clicks));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable until such time as `notifier` emits its first value.\n * @method takeUntil\n * @owner Observable\n */\nexport function takeUntil<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new TakeUntilOperator(notifier));\n}\n\nclass TakeUntilOperator<T> implements Operator<T, T> {\n  constructor(private notifier: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    const takeUntilSubscriber = new TakeUntilSubscriber(subscriber);\n    const notifierSubscription = subscribeToResult(takeUntilSubscriber, this.notifier);\n    if (notifierSubscription && !notifierSubscription.closed) {\n      takeUntilSubscriber.add(notifierSubscription);\n      return source.subscribe(takeUntilSubscriber);\n    }\n    return takeUntilSubscriber;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeUntilSubscriber<T, R> extends OuterSubscriber<T, R> {\n\n  constructor(destination: Subscriber<any>, ) {\n    super(destination);\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.complete();\n  }\n\n  notifyComplete(): void {\n    // noop\n  }\n}\n","import { Subject } from '../Subject';\nimport { Operator } from '../Operator';\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nimport { OperatorFunction, SchedulerLike, SchedulerAction } from '../types';\n\n/**\n * Branch out the source Observable values as a nested Observable periodically\n * in time.\n *\n * <span class=\"informal\">It's like {@link bufferTime}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowTime.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable starts a new window periodically, as\n * determined by the `windowCreationInterval` argument. It emits each window\n * after a fixed timespan, specified by the `windowTimeSpan` argument. When the\n * source Observable completes or encounters an error, the output Observable\n * emits the current window and propagates the notification from the source\n * Observable. If `windowCreationInterval` is not provided, the output\n * Observable starts a new window when the previous window of duration\n * `windowTimeSpan` completes. If `maxWindowCount` is provided, each window\n * will emit at most fixed number of values. Window will complete immediately\n * after emitting last value and next one still will open as specified by\n * `windowTimeSpan` and `windowCreationInterval` arguments.\n *\n * ## Examples\n * In every window of 1 second each, emit at most 2 click events\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000),\n *   map(win => win.take(2)),   // each window has at most 2 emissions\n *   mergeAll(),                // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds start a window 1 second long, and emit at most 2 click events per window\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000, 5000),\n *   map(win => win.take(2)),   // each window has at most 2 emissions\n *   mergeAll(),                // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Same as example above but with maxWindowCount instead of take\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000, 5000, 2), // each window has still at most 2 emissions\n *   mergeAll(),                // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferTime}\n *\n * @param {number} windowTimeSpan The amount of time to fill each window.\n * @param {number} [windowCreationInterval] The interval at which to start new\n * windows.\n * @param {number} [maxWindowSize=Number.POSITIVE_INFINITY] Max number of\n * values each window can emit before completion.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine window boundaries.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowTime\n * @owner Observable\n */\nexport function windowTime<T>(windowTimeSpan: number,\n                              scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\nexport function windowTime<T>(windowTimeSpan: number,\n                              windowCreationInterval: number,\n                              scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\nexport function windowTime<T>(windowTimeSpan: number,\n                              windowCreationInterval: number,\n                              maxWindowSize: number,\n                              scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\n\nexport function windowTime<T>(windowTimeSpan: number): OperatorFunction<T, Observable<T>> {\n  let scheduler: SchedulerLike = async;\n  let windowCreationInterval: number = null;\n  let maxWindowSize: number = Number.POSITIVE_INFINITY;\n\n  if (isScheduler(arguments[3])) {\n    scheduler = arguments[3];\n  }\n\n  if (isScheduler(arguments[2])) {\n    scheduler = arguments[2];\n  } else if (isNumeric(arguments[2])) {\n    maxWindowSize = arguments[2];\n  }\n\n  if (isScheduler(arguments[1])) {\n    scheduler = arguments[1];\n  } else if (isNumeric(arguments[1])) {\n    windowCreationInterval = arguments[1];\n  }\n\n  return function windowTimeOperatorFunction(source: Observable<T>) {\n    return source.lift(new WindowTimeOperator<T>(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n  };\n}\n\nclass WindowTimeOperator<T> implements Operator<T, Observable<T>> {\n\n  constructor(private windowTimeSpan: number,\n              private windowCreationInterval: number | null,\n              private maxWindowSize: number,\n              private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowTimeSubscriber(\n      subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler\n    ));\n  }\n}\n\ninterface CreationState<T> {\n  windowTimeSpan: number;\n  windowCreationInterval: number;\n  subscriber: WindowTimeSubscriber<T>;\n  scheduler: SchedulerLike;\n}\n\ninterface TimeSpanOnlyState<T> {\n    window: CountedSubject<T>;\n    windowTimeSpan: number;\n    subscriber: WindowTimeSubscriber<T>;\n  }\n\ninterface CloseWindowContext<T> {\n  action: SchedulerAction<CreationState<T>>;\n  subscription: Subscription;\n}\n\ninterface CloseState<T> {\n  subscriber: WindowTimeSubscriber<T>;\n  window: CountedSubject<T>;\n  context: CloseWindowContext<T>;\n}\n\nclass CountedSubject<T> extends Subject<T> {\n  private _numberOfNextedValues: number = 0;\n\n  next(value?: T): void {\n    this._numberOfNextedValues++;\n    super.next(value);\n  }\n\n  get numberOfNextedValues(): number {\n    return this._numberOfNextedValues;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowTimeSubscriber<T> extends Subscriber<T> {\n  private windows: CountedSubject<T>[] = [];\n\n  constructor(protected destination: Subscriber<Observable<T>>,\n              private windowTimeSpan: number,\n              private windowCreationInterval: number | null,\n              private maxWindowSize: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n\n    const window = this.openWindow();\n    if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n      const closeState: CloseState<T> = { subscriber: this, window, context: <any>null };\n      const creationState: CreationState<T> = { windowTimeSpan, windowCreationInterval, subscriber: this, scheduler };\n      this.add(scheduler.schedule<CloseState<T>>(dispatchWindowClose, windowTimeSpan, closeState));\n      this.add(scheduler.schedule<CreationState<T>>(dispatchWindowCreation, windowCreationInterval, creationState));\n    } else {\n      const timeSpanOnlyState: TimeSpanOnlyState<T> = { subscriber: this, window, windowTimeSpan };\n      this.add(scheduler.schedule<TimeSpanOnlyState<T>>(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n    }\n  }\n\n  protected _next(value: T): void {\n    const windows = this.windows;\n    const len = windows.length;\n    for (let i = 0; i < len; i++) {\n      const window = windows[i];\n      if (!window.closed) {\n        window.next(value);\n        if (window.numberOfNextedValues >= this.maxWindowSize) {\n          this.closeWindow(window);\n        }\n      }\n    }\n  }\n\n  protected _error(err: any): void {\n    const windows = this.windows;\n    while (windows.length > 0) {\n      windows.shift().error(err);\n    }\n    this.destination.error(err);\n  }\n\n  protected _complete(): void {\n    const windows = this.windows;\n    while (windows.length > 0) {\n      const window = windows.shift();\n      if (!window.closed) {\n        window.complete();\n      }\n    }\n    this.destination.complete();\n  }\n\n  public openWindow(): CountedSubject<T> {\n    const window = new CountedSubject<T>();\n    this.windows.push(window);\n    const destination = this.destination;\n    destination.next(window);\n    return window;\n  }\n\n  public closeWindow(window: CountedSubject<T>): void {\n    window.complete();\n    const windows = this.windows;\n    windows.splice(windows.indexOf(window), 1);\n  }\n}\n\nfunction dispatchWindowTimeSpanOnly<T>(this: SchedulerAction<TimeSpanOnlyState<T>>, state: TimeSpanOnlyState<T>): void {\n  const { subscriber, windowTimeSpan, window } = state;\n  if (window) {\n    subscriber.closeWindow(window);\n  }\n  state.window = subscriber.openWindow();\n  this.schedule(state, windowTimeSpan);\n}\n\nfunction dispatchWindowCreation<T>(this: SchedulerAction<CreationState<T>>, state: CreationState<T>): void {\n  const { windowTimeSpan, subscriber, scheduler, windowCreationInterval } = state;\n  const window = subscriber.openWindow();\n  const action = this;\n  let context: CloseWindowContext<T> = { action, subscription: <any>null };\n  const timeSpanState: CloseState<T> = { subscriber, window, context };\n  context.subscription = scheduler.schedule<CloseState<T>>(dispatchWindowClose, windowTimeSpan, timeSpanState);\n  action.add(context.subscription);\n  action.schedule(state, windowCreationInterval);\n}\n\nfunction dispatchWindowClose<T>(state: CloseState<T>): void {\n  const { subscriber, window, context } = state;\n  if (context && context.action && context.subscription) {\n    context.action.remove(context.subscription);\n  }\n  subscriber.closeWindow(window);\n}\n","let _enable_super_gross_mode_that_will_cause_bad_things = false;\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like what Promise contructor should used to create Promises\n */\nexport const config = {\n  /**\n   * The promise constructor used by default for methods such as\n   * {@link toPromise} and {@link forEach}\n   */\n  Promise: undefined as PromiseConstructorLike,\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BY TIME\n   * FOR MIGRATION REASONS.\n   */\n  set useDeprecatedSynchronousErrorHandling(value: boolean) {\n    if (value) {\n      const error = new Error();\n      console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \\n' + error.stack);\n    } else if (_enable_super_gross_mode_that_will_cause_bad_things) {\n      console.log('RxJS: Back to a better error behavior. Thank you. <3');\n    }\n    _enable_super_gross_mode_that_will_cause_bad_things = value;\n  },\n\n  get useDeprecatedSynchronousErrorHandling() {\n    return _enable_super_gross_mode_that_will_cause_bad_things;\n  },\n};\n","import { Observer } from './types';\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\n\nexport const empty: Observer<any> = {\n  closed: true,\n  next(value: any): void { /* noop */},\n  error(err: any): void {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      throw err;\n    } else {\n      hostReportError(err);\n    }\n  },\n  complete(): void { /*noop*/ }\n};\n","/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport class UnsubscriptionError extends Error {\n\n  public readonly name = 'UnsubscriptionError';\n\n  constructor(public errors: any[]) {\n    super(errors ?\n      `${errors.length} errors occurred during unsubscription:\n  ${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '');\n    (Object as any).setPrototypeOf(this, UnsubscriptionError.prototype);\n  }\n}\n","export const rxSubscriber =\n  (typeof Symbol === 'function' && typeof Symbol.for === 'function')\n    ? Symbol.for('rxSubscriber')\n    : '@@rxSubscriber';\n\n/**\n * @deprecated use rxSubscriber instead\n */\nexport const $$rxSubscriber = rxSubscriber;\n","import { Subscriber } from './Subscriber';\nimport { InnerSubscriber } from './InnerSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class OuterSubscriber<T, R> extends Subscriber<T> {\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.destination.next(innerValue);\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, R>): void {\n    this.destination.error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, R>): void {\n    this.destination.complete();\n  }\n}\n","import { Subscriber } from './Subscriber';\nimport { OuterSubscriber } from './OuterSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class InnerSubscriber<T, R> extends Subscriber<R> {\n  private index = 0;\n\n  constructor(private parent: OuterSubscriber<T, R>, public outerValue: T, public outerIndex: number) {\n    super();\n  }\n\n  protected _next(value: R): void {\n    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n  }\n\n  protected _error(error: any): void {\n    this.parent.notifyError(error, this);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.parent.notifyComplete(this);\n    this.unsubscribe();\n  }\n}\n","import { Subscriber } from '../Subscriber';\nimport { rxSubscriber as rxSubscriberSymbol } from '../symbol/rxSubscriber';\nimport { empty as emptyObserver } from '../Observer';\nimport { PartialObserver } from '../types';\n\nexport function toSubscriber<T>(\n  nextOrObserver?: PartialObserver<T> | ((value: T) => void),\n  error?: (error: any) => void,\n  complete?: () => void): Subscriber<T> {\n\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return (<Subscriber<T>> nextOrObserver);\n    }\n\n    if (nextOrObserver[rxSubscriberSymbol]) {\n      return nextOrObserver[rxSubscriberSymbol]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(emptyObserver);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n","import { noop } from './noop';\nimport { UnaryFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function pipe<T>(): UnaryFunction<T, T>;\nexport function pipe<T, A>(op1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>, op9: UnaryFunction<H, I>): UnaryFunction<T, I>;\n/* tslint:enable:max-line-length */\n\nexport function pipe<T, R>(...fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  return pipeFromArray(fns);\n}\n\n/* @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (!fns) {\n    return noop as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n","import { Subscriber } from '../Subscriber';\n\n/**\n * Subscribes to an ArrayLike with a subscriber\n * @param array The array or array-like to subscribe to\n */\nexport const subscribeToArray = <T>(array: ArrayLike<T>) => (subscriber: Subscriber<T>) => {\n  for (let i = 0, len = array.length; i < len && !subscriber.closed; i++) {\n    subscriber.next(array[i]);\n  }\n  if (!subscriber.closed) {\n    subscriber.complete();\n  }\n};\n","export function getSymbolIterator(): symbol {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator' as any;\n  }\n\n  return Symbol.iterator;\n}\n\nexport const iterator = getSymbolIterator();\n\n/**\n * @deprecated use {@link iterator} instead\n */\nexport const $$iterator = iterator;\n","import { Observable } from '../Observable';\nimport { ObservableInput } from '../types';\nimport { subscribeToArray } from './subscribeToArray';\nimport { subscribeToPromise } from './subscribeToPromise';\nimport { subscribeToIterable } from './subscribeToIterable';\nimport { subscribeToObservable } from './subscribeToObservable';\nimport { isArrayLike } from './isArrayLike';\nimport { isPromise } from './isPromise';\nimport { isObject } from './isObject';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { observable as Symbol_observable } from '../symbol/observable';\nimport { Subscriber } from '../Subscriber';\n\nexport const subscribeTo = <T>(result: ObservableInput<T>) => {\n  if (result instanceof Observable) {\n    return (subscriber: Subscriber<T>) => {\n        if (result._isScalar) {\n        subscriber.next((result as any).value);\n        subscriber.complete();\n        return undefined;\n      } else {\n        return result.subscribe(subscriber);\n      }\n    };\n  } else if (result && typeof result[Symbol_observable] === 'function') {\n    return subscribeToObservable(result as any);\n  } else if (isArrayLike(result)) {\n    return subscribeToArray(result);\n  } else if (isPromise(result)) {\n    return subscribeToPromise(result as Promise<any>);\n  } else if (result && typeof result[Symbol_iterator] === 'function') {\n    return subscribeToIterable(result as any);\n  } else {\n    const value = isObject(result) ? 'an invalid object' : `'${result}'`;\n    const msg = `You provided ${value} where a stream was expected.`\n      + ' You can provide an Observable, Promise, Array, or Iterable.';\n    throw new TypeError(msg);\n  }\n};\n","import { Subscriber } from '../Subscriber';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\n/**\n * Subscribes to an object that implements Symbol.observable with the given\n * Subscriber.\n * @param obj An object that implements Symbol.observable\n */\nexport const subscribeToObservable = <T>(obj: any) => (subscriber: Subscriber<T>) => {\n  const obs = obj[Symbol_observable]();\n  if (typeof obs.subscribe !== 'function') {\n    // Should be caught by observable subscribe function error handling.\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\n  } else {\n    return obs.subscribe(subscriber);\n  }\n};\n","export function isPromise(value: any): value is PromiseLike<any> {\n  return value && typeof (<any>value).subscribe !== 'function' && typeof (value as any).then === 'function';\n}\n","import { Subscriber } from '../Subscriber';\nimport { hostReportError } from './hostReportError';\n\nexport const subscribeToPromise = <T>(promise: PromiseLike<T>) => (subscriber: Subscriber<T>) => {\n  promise.then(\n    (value) => {\n      if (!subscriber.closed) {\n        subscriber.next(value);\n        subscriber.complete();\n      }\n    },\n    (err: any) => subscriber.error(err)\n  )\n  .then(null, hostReportError);\n  return subscriber;\n};\n","import { Subscriber } from '../Subscriber';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\n\nexport const subscribeToIterable = <T>(iterable: Iterable<T>) => (subscriber: Subscriber<T>) => {\n  const iterator = iterable[Symbol_iterator]();\n  do {\n    const item = iterator.next();\n    if (item.done) {\n      subscriber.complete();\n      break;\n    }\n    subscriber.next(item.value);\n    if (subscriber.closed) {\n      break;\n    }\n  } while (true);\n\n  // Finalize the iterator if it happens to be a Generator\n  if (typeof iterator.return === 'function') {\n    subscriber.add(() => {\n      if (iterator.return) {\n        iterator.return();\n      }\n    });\n  }\n\n  return subscriber;\n};\n","import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AsyncAction<T> extends Action<T> {\n\n  public id: any;\n  public state: T;\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler,\n              protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n\n    if (this.closed) {\n      return this;\n     }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, id?: any, delay: number = 0): any {\n    return setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(scheduler: AsyncScheduler, id: any, delay: number = 0): any {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    return clearInterval(id) && undefined || undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any = undefined;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n    const actions = scheduler.actions;\n    const index = actions.indexOf(this);\n\n    this.work  = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SubscribableOrPromise, TeardownLogic } from '../types';\n\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/audit.png\" width=\"100%\">\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(audit(ev => Rx.Observable.interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nexport function audit<T>(durationSelector: (value: T) => SubscribableOrPromise<any>): MonoTypeOperatorFunction<T> {\n  return function auditOperatorFunction(source: Observable<T>) {\n    return source.lift(new AuditOperator(durationSelector));\n  };\n}\n\nclass AuditOperator<T> implements Operator<T, T> {\n  constructor(private durationSelector: (value: T) => SubscribableOrPromise<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new AuditSubscriber<T, T>(subscriber, this.durationSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass AuditSubscriber<T, R> extends OuterSubscriber<T, R> {\n\n  private value: T;\n  private hasValue: boolean = false;\n  private throttled: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private durationSelector: (value: T) => SubscribableOrPromise<any>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    this.value = value;\n    this.hasValue = true;\n    if (!this.throttled) {\n      const duration = tryCatch(this.durationSelector)(value);\n      if (duration === errorObject) {\n        this.destination.error(errorObject.e);\n      } else {\n        const innerSubscription = subscribeToResult(this, duration);\n        if (!innerSubscription || innerSubscription.closed) {\n          this.clearThrottle();\n        } else {\n          this.add(this.throttled = innerSubscription);\n        }\n      }\n    }\n  }\n\n  clearThrottle() {\n    const { value, hasValue, throttled } = this;\n    if (throttled) {\n      this.remove(throttled);\n      this.throttled = null;\n      throttled.unsubscribe();\n    }\n    if (hasValue) {\n      this.value = null;\n      this.hasValue = false;\n      this.destination.next(value);\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number): void {\n    this.clearThrottle();\n  }\n\n  notifyComplete(): void {\n    this.clearThrottle();\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\nimport { SchedulerAction } from '../types';\n\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent Scheduler for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler.\n   * @return {void}\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n","import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\nimport { SchedulerLike, SchedulerAction } from './types';\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}\n */\nexport class Scheduler implements SchedulerLike {\n\n  /** @nocollapse */\n  public static now: () => number = Date.now ? Date.now : () => +new Date();\n\n  constructor(private SchedulerAction: typeof Action,\n              now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return {number} A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param {function(state: ?T): ?Subscription} work A function representing a\n   * task, or some unit of work to be executed by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler itself.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @return {Subscription} A subscription in order to be able to unsubscribe\n   * the scheduled work.\n   */\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.SchedulerAction<T>(this, work).schedule(state, delay);\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\n\nexport class AsyncScheduler extends Scheduler {\n  public static delegate?: Scheduler;\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   * @deprecated internal use only\n   */\n  public active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   * @deprecated internal use only\n   */\n  public scheduled: any = undefined;\n\n  constructor(SchedulerAction: typeof Action,\n              now: () => number = Scheduler.now) {\n    super(SchedulerAction, () => {\n      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n        return AsyncScheduler.delegate.now();\n      } else {\n        return now();\n      }\n    });\n  }\n\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n      return AsyncScheduler.delegate.schedule(work, delay, state);\n    } else {\n      return super.schedule(work, delay, state);\n    }\n  }\n\n  public flush(action: AsyncAction<any>): void {\n\n    const {actions} = this;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift()); // exhaust the scheduler queue\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asap} scheduler.\n *\n * ## Examples\n * Use async scheduler to delay task\n * ```javascript\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n * ```\n *\n * Use async scheduler to repeat task in intervals\n * ```javascript\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n * ```\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\n\nexport const async = new AsyncScheduler(AsyncAction);\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../types';\n\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * <img src=\"./img/buffer.png\" width=\"100%\">\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * Observable emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * ## Example\n *\n * On every click, emit array of most recent interval events\n *\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const interval = interval(1000);\n * const buffered = interval.pipe(buffer(clicks));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param {Observable<any>} closingNotifier An Observable that signals the\n * buffer to be emitted on the output Observable.\n * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n * values.\n * @method buffer\n * @owner Observable\n */\nexport function buffer<T>(closingNotifier: Observable<any>): OperatorFunction<T, T[]> {\n  return function bufferOperatorFunction(source: Observable<T>) {\n    return source.lift(new BufferOperator<T>(closingNotifier));\n  };\n}\n\nclass BufferOperator<T> implements Operator<T, T[]> {\n\n  constructor(private closingNotifier: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): any {\n    return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferSubscriber<T> extends OuterSubscriber<T, any> {\n  private buffer: T[] = [];\n\n  constructor(destination: Subscriber<T[]>, closingNotifier: Observable<any>) {\n    super(destination);\n    this.add(subscribeToResult(this, closingNotifier));\n  }\n\n  protected _next(value: T) {\n    this.buffer.push(value);\n  }\n\n  notifyNext(outerValue: T, innerValue: any,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, any>): void {\n    const buffer = this.buffer;\n    this.buffer = [];\n    this.destination.next(buffer);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * <img src=\"./img/bufferCount.png\" width=\"100%\">\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * ## Examples\n *\n * Emit the last two click events as an array\n *\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferCount(2));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * On every click, emit the last two click events as an array\n *\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferCount(2, 1));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\n * @method bufferCount\n * @owner Observable\n */\nexport function bufferCount<T>(bufferSize: number, startBufferEvery: number = null): OperatorFunction<T, T[]> {\n  return function bufferCountOperatorFunction(source: Observable<T>) {\n    return source.lift(new BufferCountOperator<T>(bufferSize, startBufferEvery));\n  };\n}\n\nclass BufferCountOperator<T> implements Operator<T, T[]> {\n  private subscriberClass: any;\n\n  constructor(private bufferSize: number, private startBufferEvery: number) {\n    if (!startBufferEvery || bufferSize === startBufferEvery) {\n      this.subscriberClass = BufferCountSubscriber;\n    } else {\n      this.subscriberClass = BufferSkipCountSubscriber;\n    }\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): TeardownLogic {\n    return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferCountSubscriber<T> extends Subscriber<T> {\n  private buffer: T[] = [];\n\n  constructor(destination: Subscriber<T[]>, private bufferSize: number) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const buffer = this.buffer;\n\n    buffer.push(value);\n\n    if (buffer.length == this.bufferSize) {\n      this.destination.next(buffer);\n      this.buffer = [];\n    }\n  }\n\n  protected _complete(): void {\n    const buffer = this.buffer;\n    if (buffer.length > 0) {\n      this.destination.next(buffer);\n    }\n    super._complete();\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferSkipCountSubscriber<T> extends Subscriber<T> {\n  private buffers: Array<T[]> = [];\n  private count: number = 0;\n\n  constructor(destination: Subscriber<T[]>, private bufferSize: number, private startBufferEvery: number) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const { bufferSize, startBufferEvery, buffers, count } = this;\n\n    this.count++;\n    if (count % startBufferEvery === 0) {\n      buffers.push([]);\n    }\n\n    for (let i = buffers.length; i--; ) {\n      const buffer = buffers[i];\n      buffer.push(value);\n      if (buffer.length === bufferSize) {\n        buffers.splice(i, 1);\n        this.destination.next(buffer);\n      }\n    }\n  }\n\n  protected _complete(): void {\n    const { buffers, destination } = this;\n\n    while (buffers.length > 0) {\n      let buffer = buffers.shift();\n      if (buffer.length > 0) {\n        destination.next(buffer);\n      }\n    }\n    super._complete();\n  }\n\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { isScheduler  } from '../util/isScheduler';\nimport { isArray  } from '../util/isArray';\nimport { Subscriber } from '../Subscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { Operator } from '../Operator';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { fromArray } from './fromArray';\n\nconst NONE = {};\n\n/* tslint:disable:max-line-length */\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<T, R>(v1: ObservableInput<T>, resultSelector: (v1: T) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<T, T2, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, resultSelector: (v1: T, v2: T2) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<T, T2, T3, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<T, T2, T3, T4, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<T, T2, T3, T4, T5, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<T, T2, T3, T4, T5, T6, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R, scheduler?: SchedulerLike): Observable<R>;\n\nexport function combineLatest<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: SchedulerLike): Observable<[T, T2]>;\nexport function combineLatest<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): Observable<[T, T2, T3]>;\nexport function combineLatest<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): Observable<[T, T2, T3, T4]>;\nexport function combineLatest<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): Observable<[T, T2, T3, T4, T5]>;\nexport function combineLatest<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): Observable<[T, T2, T3, T4, T5, T6]>;\n\nexport function combineLatest<T>(array: ObservableInput<T>[], scheduler?: SchedulerLike): Observable<T[]>;\nexport function combineLatest<R>(array: ObservableInput<any>[], scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<T, R>(array: ObservableInput<T>[], resultSelector: (...values: Array<T>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<R>(array: ObservableInput<any>[], resultSelector: (...values: Array<any>) => R, scheduler?: SchedulerLike): Observable<R>;\nexport function combineLatest<T>(...observables: Array<ObservableInput<T> | SchedulerLike>): Observable<T[]>;\nexport function combineLatest<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R) | SchedulerLike>): Observable<R>;\nexport function combineLatest<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R) | SchedulerLike>): Observable<R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from all the Observables passed as\n * arguments. This is done by subscribing to each Observable in order and,\n * whenever any Observable emits, collecting an array of the most recent\n * values from each Observable. So if you pass `n` Observables to operator,\n * returned Observable will always emit an array of `n` values, in order\n * corresponding to order of passed Observables (value from the first Observable\n * on the first place and so on).\n *\n * Static version of `combineLatest` accepts either an array of Observables\n * or each Observable can be put directly as an argument. Note that array of\n * Observables is good choice, if you don't know beforehand how many Observables\n * you will combine. Passing empty array will result in Observable that\n * completes immediately.\n *\n * To ensure output array has always the same length, `combineLatest` will\n * actually wait for all input Observables to emit at least once,\n * before it starts emitting results. This means if some Observable emits\n * values before other Observables started emitting, all that values but last\n * will be lost. On the other hand, is some Observable does not emit value but\n * completes, resulting Observable will complete at the same moment without\n * emitting anything, since it will be now impossible to include value from\n * completed Observable in resulting array. Also, if some input Observable does\n * not emit any value and never completes, `combineLatest` will also never emit\n * and never complete, since, again, it will wait for all streams to emit some\n * value.\n *\n * If at least one Observable was passed to `combineLatest` and all passed Observables\n * emitted something, resulting Observable will complete when all combined\n * streams complete. So even if some Observable completes, result of\n * `combineLatest` will still emit values when other Observables do. In case\n * of completed Observable, its value from now on will always be the last\n * emitted value. On the other hand, if any Observable errors, `combineLatest`\n * will error immediately as well, and all other Observables will be unsubscribed.\n *\n * `combineLatest` accepts as optional parameter `project` function, which takes\n * as arguments all values that would normally be emitted by resulting Observable.\n * `project` can return any kind of value, which will be then emitted by Observable\n * instead of default array. Note that `project` does not take as argument that array\n * of values, but values themselves. That means default `project` can be imagined\n * as function that takes all its arguments and puts them into an array.\n *\n * ## Examples\n * ### Combine two timer Observables\n * ```javascript\n * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now\n * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now\n * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);\n * combinedTimers.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0] after 0.5s\n * // [1, 0] after 1s\n * // [1, 1] after 1.5s\n * // [2, 1] after 2s\n * ```\n *\n * ### Combine an array of Observables\n * ```javascript\n * const observables = [1, 5, 10].map(\n *   n => of(n).pipe(\n *     delay(n * 1000),   // emit 0 and then emit n after n seconds\n *     startWith(0),\n *   )\n * );\n * const combined = combineLatest(observables);\n * combined.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0, 0] immediately\n * // [1, 0, 0] after 1s\n * // [1, 5, 0] after 5s\n * // [1, 5, 10] after 10s\n * ```\n *\n *\n * ### Use project function to dynamically calculate the Body-Mass Index\n * ```javascript\n * * const weight = of(70, 72, 76, 79, 75);\n * const height = of(1.76, 1.77, 1.78);\n * const bmi = combineLatest(weight, height).pipe(\n *   map(([w, h]) => w / (h * h)),\n * );\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n * ```\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} observable1 An input Observable to combine with other Observables.\n * @param {ObservableInput} observable2 An input Observable to combine with other Observables.\n * More than one input Observables may be given as arguments\n * or an array of Observables may be given as the first argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each input Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n */\nexport function combineLatest<T, R>(...observables: Array<any | ObservableInput<any> |\n                                                    Array<ObservableInput<any>> |\n                                                    (((...values: Array<any>) => R)) |\n                                                    SchedulerLike>): Observable<R> {\n  let resultSelector: (...values: Array<any>) => R =  null;\n  let scheduler: SchedulerLike = null;\n\n  if (isScheduler(observables[observables.length - 1])) {\n    scheduler = <SchedulerLike>observables.pop();\n  }\n\n  if (typeof observables[observables.length - 1] === 'function') {\n    resultSelector = <(...values: Array<any>) => R>observables.pop();\n  }\n\n  // if the first and only other argument besides the resultSelector is an array\n  // assume it's been called with `combineLatest([obs1, obs2, obs3], resultSelector)`\n  if (observables.length === 1 && isArray(observables[0])) {\n    observables = <Array<Observable<any>>>observables[0];\n  }\n\n  return fromArray(observables, scheduler).lift(new CombineLatestOperator<T, R>(resultSelector));\n}\n\nexport class CombineLatestOperator<T, R> implements Operator<T, R> {\n  constructor(private resultSelector?: (...values: Array<any>) => R) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class CombineLatestSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private active: number = 0;\n  private values: any[] = [];\n  private observables: any[] = [];\n  private toRespond: number;\n\n  constructor(destination: Subscriber<R>, private resultSelector?: (...values: Array<any>) => R) {\n    super(destination);\n  }\n\n  protected _next(observable: any) {\n    this.values.push(NONE);\n    this.observables.push(observable);\n  }\n\n  protected _complete() {\n    const observables = this.observables;\n    const len = observables.length;\n    if (len === 0) {\n      this.destination.complete();\n    } else {\n      this.active = len;\n      this.toRespond = len;\n      for (let i = 0; i < len; i++) {\n        const observable = observables[i];\n        this.add(subscribeToResult(this, observable, observable, i));\n      }\n    }\n  }\n\n  notifyComplete(unused: Subscriber<R>): void {\n    if ((this.active -= 1) === 0) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    const values = this.values;\n    const oldVal = values[outerIndex];\n    const toRespond = !this.toRespond\n      ? 0\n      : oldVal === NONE ? --this.toRespond : this.toRespond;\n    values[outerIndex] = innerValue;\n\n    if (toRespond === 0) {\n      if (this.resultSelector) {\n        this._tryResultSelector(values);\n      } else {\n        this.destination.next(values.slice());\n      }\n    }\n  }\n\n  private _tryResultSelector(values: any[]) {\n    let result: any;\n    try {\n      result = this.resultSelector.apply(this, values);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OperatorFunction, SubscribableOrPromise } from '../types';\n\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * <img src=\"./img/bufferToggle.png\" width=\"100%\">\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * ## Example\n *\n * Every other second, emit the click events from the next 500ms\n *\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const openings = interval(1000);\n * const buffered = clicks.pipe(bufferToggle(openings, i =>\n *   i % 2 ? interval(500) : empty()\n * ));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferToggle\n * @owner Observable\n */\nexport function bufferToggle<T, O>(\n  openings: SubscribableOrPromise<O>,\n  closingSelector: (value: O) => SubscribableOrPromise<any>\n): OperatorFunction<T, T[]> {\n  return function bufferToggleOperatorFunction(source: Observable<T>) {\n    return source.lift(new BufferToggleOperator<T, O>(openings, closingSelector));\n  };\n}\n\nclass BufferToggleOperator<T, O> implements Operator<T, T[]> {\n\n  constructor(private openings: SubscribableOrPromise<O>,\n              private closingSelector: (value: O) => SubscribableOrPromise<any>) {\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): any {\n    return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));\n  }\n}\n\ninterface BufferContext<T> {\n  buffer: T[];\n  subscription: Subscription;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferToggleSubscriber<T, O> extends OuterSubscriber<T, O> {\n  private contexts: Array<BufferContext<T>> = [];\n\n  constructor(destination: Subscriber<T[]>,\n              private openings: SubscribableOrPromise<O>,\n              private closingSelector: (value: O) => SubscribableOrPromise<any> | void) {\n    super(destination);\n    this.add(subscribeToResult(this, openings));\n  }\n\n  protected _next(value: T): void {\n    const contexts = this.contexts;\n    const len = contexts.length;\n    for (let i = 0; i < len; i++) {\n      contexts[i].buffer.push(value);\n    }\n  }\n\n  protected _error(err: any): void {\n    const contexts = this.contexts;\n    while (contexts.length > 0) {\n      const context = contexts.shift();\n      context.subscription.unsubscribe();\n      context.buffer = null;\n      context.subscription = null;\n    }\n    this.contexts = null;\n    super._error(err);\n  }\n\n  protected _complete(): void {\n    const contexts = this.contexts;\n    while (contexts.length > 0) {\n      const context = contexts.shift();\n      this.destination.next(context.buffer);\n      context.subscription.unsubscribe();\n      context.buffer = null;\n      context.subscription = null;\n    }\n    this.contexts = null;\n    super._complete();\n  }\n\n  notifyNext(outerValue: any, innerValue: O,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, O>): void {\n    outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, O>): void {\n    this.closeBuffer((<any> innerSub).context);\n  }\n\n  private openBuffer(value: O): void {\n    try {\n      const closingSelector = this.closingSelector;\n      const closingNotifier = closingSelector.call(this, value);\n      if (closingNotifier) {\n        this.trySubscribe(closingNotifier);\n      }\n    } catch (err) {\n      this._error(err);\n    }\n  }\n\n  private closeBuffer(context: BufferContext<T>): void {\n    const contexts = this.contexts;\n\n    if (contexts && context) {\n      const { buffer, subscription } = context;\n      this.destination.next(buffer);\n      contexts.splice(contexts.indexOf(context), 1);\n      this.remove(subscription);\n      subscription.unsubscribe();\n    }\n  }\n\n  private trySubscribe(closingNotifier: any): void {\n    const contexts = this.contexts;\n\n    const buffer: Array<T> = [];\n    const subscription = new Subscription();\n    const context = { buffer, subscription };\n    contexts.push(context);\n\n    const innerSubscription = subscribeToResult(this, closingNotifier, <any>context);\n\n    if (!innerSubscription || innerSubscription.closed) {\n      this.closeBuffer(context);\n    } else {\n      (<any> innerSubscription).context = context;\n\n      this.add(innerSubscription);\n      subscription.add(innerSubscription);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../types';\n\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * <img src=\"./img/bufferWhen.png\" width=\"100%\">\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * ## Example\n *\n * Emit an array of the last clicks every [1-5] random seconds\n *\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferWhen(() =>\n *   interval(1000 + Math.random() * 4000)\n * ));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals buffer closure.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferWhen\n * @owner Observable\n */\nexport function bufferWhen<T>(closingSelector: () => Observable<any>): OperatorFunction<T, T[]> {\n  return function (source: Observable<T>) {\n    return source.lift(new BufferWhenOperator(closingSelector));\n  };\n}\n\nclass BufferWhenOperator<T> implements Operator<T, T[]> {\n\n  constructor(private closingSelector: () => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): any {\n    return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferWhenSubscriber<T> extends OuterSubscriber<T, any> {\n  private buffer: T[];\n  private subscribing: boolean = false;\n  private closingSubscription: Subscription;\n\n  constructor(destination: Subscriber<T[]>, private closingSelector: () => Observable<any>) {\n    super(destination);\n    this.openBuffer();\n  }\n\n  protected _next(value: T) {\n    this.buffer.push(value);\n  }\n\n  protected _complete() {\n    const buffer = this.buffer;\n    if (buffer) {\n      this.destination.next(buffer);\n    }\n    super._complete();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    this.buffer = null;\n    this.subscribing = false;\n  }\n\n  notifyNext(outerValue: T, innerValue: any,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, any>): void {\n    this.openBuffer();\n  }\n\n  notifyComplete(): void {\n    if (this.subscribing) {\n      this.complete();\n    } else {\n      this.openBuffer();\n    }\n  }\n\n  openBuffer() {\n\n    let { closingSubscription } = this;\n\n    if (closingSubscription) {\n      this.remove(closingSubscription);\n      closingSubscription.unsubscribe();\n    }\n\n    const buffer = this.buffer;\n    if (this.buffer) {\n      this.destination.next(buffer);\n    }\n\n    this.buffer = [];\n\n    const closingNotifier = tryCatch(this.closingSelector)();\n\n    if (closingNotifier === errorObject) {\n      this.error(errorObject.e);\n    } else {\n      closingSubscription = new Subscription();\n      this.closingSubscription = closingSubscription;\n      this.add(closingSubscription);\n      this.subscribing = true;\n      closingSubscription.add(subscribeToResult(this, closingNotifier));\n      this.subscribing = false;\n    }\n  }\n}\n","import {Operator} from '../Operator';\nimport {Subscriber} from '../Subscriber';\nimport {Observable} from '../Observable';\n\nimport {OuterSubscriber} from '../OuterSubscriber';\nimport {subscribeToResult} from '../util/subscribeToResult';\nimport {ObservableInput, OperatorFunction, MonoTypeOperatorFunction} from '../types';\n\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <img src=\"./img/catch.png\" width=\"100%\">\n *\n * ## Examples\n * Continues with a different Observable when there's an error\n *\n * ```javascript\n * of(1, 2, 3, 4, 5).pipe(\n *     map(n => {\n *   \t   if (n == 4) {\n * \t       throw 'four!';\n *       }\n *\t     return n;\n *     }),\n *     catchError(err => of('I', 'II', 'III', 'IV', 'V')),\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n * ```\n *\n * Retries the caught source Observable again in case of error, similar to retry() operator\n *\n * ```javascript\n * of(1, 2, 3, 4, 5).pipe(\n *     map(n => {\n *   \t   if (n === 4) {\n *   \t     throw 'four!';\n *       }\n * \t     return n;\n *     }),\n *     catchError((err, caught) => caught),\n *     take(30),\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n * ```\n *\n * Throws a new error when the source Observable throws an error\n *\n * ```javascript\n * of(1, 2, 3, 4, 5).pipe(\n *     map(n => {\n *       if (n == 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError(err => {\n *       throw 'error in source. Details: ' + err;\n *     }),\n *   )\n *   .subscribe(\n *     x => console.log(x),\n *     err => console.log(err)\n *   );\n *   // 1, 2, 3, error in source. Details: four!\n * ```\n *\n *  @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} An observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @name catchError\n */\nexport function catchError<T>(selector: (err: any, caught: Observable<T>) => never): MonoTypeOperatorFunction<T>;\nexport function catchError<T, R>(selector: (err: any, caught: Observable<T>) => ObservableInput<R>): OperatorFunction<T, T | R>;\nexport function catchError<T, R>(selector: (err: any, caught: Observable<T>) => ObservableInput<R>): OperatorFunction<T, T | R> {\n  return function catchErrorOperatorFunction(source: Observable<T>): Observable<T | R> {\n    const operator = new CatchOperator(selector);\n    const caught = source.lift(operator);\n    return (operator.caught = caught as Observable<T>);\n  };\n}\n\nclass CatchOperator<T, R> implements Operator<T, T | R> {\n  caught: Observable<T>;\n\n  constructor(private selector: (err: any, caught: Observable<T>) => ObservableInput<T | R>) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass CatchSubscriber<T, R> extends OuterSubscriber<T, T | R> {\n  constructor(destination: Subscriber<any>,\n              private selector: (err: any, caught: Observable<T>) => ObservableInput<T | R>,\n              private caught: Observable<T>) {\n    super(destination);\n  }\n\n  // NOTE: overriding `error` instead of `_error` because we don't want\n  // to have this flag this subscriber as `isStopped`. We can mimic the\n  // behavior of the RetrySubscriber (from the `retry` operator), where\n  // we unsubscribe from our source chain, reset our Subscriber flags,\n  // then subscribe to the selector result.\n  error(err: any) {\n    if (!this.isStopped) {\n      let result: any;\n      try {\n        result = this.selector(err, this.caught);\n      } catch (err2) {\n        super.error(err2);\n        return;\n      }\n      this._unsubscribeAndRecycle();\n      this.add(subscribeToResult(this, result));\n    }\n  }\n}\n","import { PartialObserver } from './types';\nimport { Observable } from './Observable';\nimport { empty } from './observable/empty';\nimport { of } from './observable/of';\nimport { throwError } from './observable/throwError';\n\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n *\n * @class Notification<T>\n */\nexport class Notification<T> {\n  hasValue: boolean;\n\n  constructor(public kind: string, public value?: T, public error?: any) {\n    this.hasValue = kind === 'N';\n  }\n\n  /**\n   * Delivers to the given `observer` the value wrapped by this Notification.\n   * @param {Observer} observer\n   * @return\n   */\n  observe(observer: PartialObserver<T>): any {\n    switch (this.kind) {\n      case 'N':\n        return observer.next && observer.next(this.value);\n      case 'E':\n        return observer.error && observer.error(this.error);\n      case 'C':\n        return observer.complete && observer.complete();\n    }\n  }\n\n  /**\n   * Given some {@link Observer} callbacks, deliver the value represented by the\n   * current Notification to the correctly corresponding callback.\n   * @param {function(value: T): void} next An Observer `next` callback.\n   * @param {function(err: any): void} [error] An Observer `error` callback.\n   * @param {function(): void} [complete] An Observer `complete` callback.\n   * @return {any}\n   */\n  do(next: (value: T) => void, error?: (err: any) => void, complete?: () => void): any {\n    const kind = this.kind;\n    switch (kind) {\n      case 'N':\n        return next && next(this.value);\n      case 'E':\n        return error && error(this.error);\n      case 'C':\n        return complete && complete();\n    }\n  }\n\n  /**\n   * Takes an Observer or its individual callback functions, and calls `observe`\n   * or `do` methods accordingly.\n   * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n   * the `next` callback.\n   * @param {function(err: any): void} [error] An Observer `error` callback.\n   * @param {function(): void} [complete] An Observer `complete` callback.\n   * @return {any}\n   */\n  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) {\n    if (nextOrObserver && typeof (<PartialObserver<T>>nextOrObserver).next === 'function') {\n      return this.observe(<PartialObserver<T>>nextOrObserver);\n    } else {\n      return this.do(<(value: T) => void>nextOrObserver, error, complete);\n    }\n  }\n\n  /**\n   * Returns a simple Observable that just delivers the notification represented\n   * by this Notification instance.\n   * @return {any}\n   */\n  toObservable(): Observable<T> {\n    const kind = this.kind;\n    switch (kind) {\n      case 'N':\n        return of(this.value);\n      case 'E':\n        return throwError(this.error);\n      case 'C':\n        return empty();\n    }\n    throw new Error('unexpected notification kind value');\n  }\n\n  private static completeNotification: Notification<any> = new Notification('C');\n  private static undefinedValueNotification: Notification<any> = new Notification('N', undefined);\n\n  /**\n   * A shortcut to create a Notification instance of the type `next` from a\n   * given value.\n   * @param {T} value The `next` value.\n   * @return {Notification<T>} The \"next\" Notification representing the\n   * argument.\n   * @nocollapse\n   */\n  static createNext<T>(value: T): Notification<T> {\n    if (typeof value !== 'undefined') {\n      return new Notification('N', value);\n    }\n    return Notification.undefinedValueNotification;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `error` from a\n   * given error.\n   * @param {any} [err] The `error` error.\n   * @return {Notification<T>} The \"error\" Notification representing the\n   * argument.\n   * @nocollapse\n   */\n  static createError<T>(err?: any): Notification<T> {\n    return new Notification('E', undefined, err);\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `complete`.\n   * @return {Notification<any>} The valueless \"complete\" Notification.\n   * @nocollapse\n   */\n  static createComplete(): Notification<any> {\n    return Notification.completeNotification;\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { map } from './map';\nimport { from } from '../observable/from';\n\n/* tslint:disable:max-line-length */\nexport function mergeMap<T, R>(project: (value: T, index: number) => ObservableInput<R>, concurrent?: number): OperatorFunction<T, R>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport function mergeMap<T, R>(project: (value: T, index: number) => ObservableInput<R>, resultSelector: undefined, concurrent?: number): OperatorFunction<T, R>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport function mergeMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * ## Example\n * Map and flatten each letter to an Observable ticking every 1 second\n * ```javascript\n * const letters = of('a', 'b', 'c');\n * const result = letters.pipe(\n *   mergeMap(x => interval(1000).pipe(map(i => x+i))),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nexport function mergeMap<T, I, R>(\n  project: (value: T, index: number) => ObservableInput<I>,\n  resultSelector?: ((outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) | number,\n  concurrent: number = Number.POSITIVE_INFINITY\n): OperatorFunction<T, I|R> {\n  if (typeof resultSelector === 'function') {\n    // DEPRECATED PATH\n    return (source: Observable<T>) => source.pipe(\n      mergeMap((a, i) => from(project(a, i)).pipe(\n        map((b, ii) => resultSelector(a, b, i, ii)),\n      ), concurrent)\n    );\n  } else if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n  return (source: Observable<T>) => source.lift(new MergeMapOperator(project, concurrent));\n}\n\nexport class MergeMapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => ObservableInput<R>,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n  }\n\n  call(observer: Subscriber<R>, source: any): any {\n    return source.subscribe(new MergeMapSubscriber(\n      observer, this.project, this.concurrent\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class MergeMapSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private hasCompleted: boolean = false;\n  private buffer: T[] = [];\n  private active: number = 0;\n  protected index: number = 0;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => ObservableInput<R>,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (this.active < this.concurrent) {\n      this._tryNext(value);\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  protected _tryNext(value: T) {\n    let result: ObservableInput<R>;\n    const index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.active++;\n    this._innerSub(result, value, index);\n  }\n\n  private _innerSub(ish: ObservableInput<R>, value: T, index: number): void {\n    this.add(subscribeToResult<T, R>(this, ish, value, index));\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (this.active === 0 && this.buffer.length === 0) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.destination.next(innerValue);\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    const buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      this.destination.complete();\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Observer, OperatorFunction } from '../types';\nimport { Subscriber } from '../Subscriber';\n/**\n * Counts the number of emissions on the source and emits that number when the\n * source completes.\n *\n * <span class=\"informal\">Tells how many values were emitted, when the source\n * completes.</span>\n *\n * <img src=\"./img/count.png\" width=\"100%\">\n *\n * `count` transforms an Observable that emits values into an Observable that\n * emits a single value that represents the number of values emitted by the\n * source Observable. If the source Observable terminates with an error, `count`\n * will pass this error notification along without emitting a value first. If\n * the source Observable does not terminate at all, `count` will neither emit\n * a value nor terminate. This operator takes an optional `predicate` function\n * as argument, in which case the output emission will represent the number of\n * source values that matched `true` with the `predicate`.\n *\n * ## Examples\n *\n * Counts how many seconds have passed before the first click happened\n * ```javascript\n * const seconds = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const secondsBeforeClick = seconds.pipe(takeUntil(clicks));\n * const result = secondsBeforeClick.pipe(count());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Counts how many odd numbers are there between 1 and 7\n * ```javascript\n * const numbers = range(1, 7);\n * const result = numbers.pipe(count(i => i % 2 === 1));\n * result.subscribe(x => console.log(x));\n * // Results in:\n * // 4\n * ```javascript\n *\n * @see {@link max}\n * @see {@link min}\n * @see {@link reduce}\n *\n * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A\n * boolean function to select what values are to be counted. It is provided with\n * arguments of:\n * - `value`: the value from the source Observable.\n * - `index`: the (zero-based) \"index\" of the value from the source Observable.\n * - `source`: the source Observable instance itself.\n * @return {Observable} An Observable of one number that represents the count as\n * described above.\n * @method count\n * @owner Observable\n */\n\nexport function count<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): OperatorFunction<T, number> {\n  return (source: Observable<T>) => source.lift(new CountOperator(predicate, source));\n}\n\nclass CountOperator<T> implements Operator<T, number> {\n  constructor(private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private source?: Observable<T>) {\n  }\n\n  call(subscriber: Subscriber<number>, source: any): any {\n    return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass CountSubscriber<T> extends Subscriber<T> {\n  private count: number = 0;\n  private index: number = 0;\n\n  constructor(destination: Observer<number>,\n              private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private source?: Observable<T>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (this.predicate) {\n      this._tryPredicate(value);\n    } else {\n      this.count++;\n    }\n  }\n\n  private _tryPredicate(value: T) {\n    let result: any;\n\n    try {\n      result = this.predicate(value, this.index++, this.source);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    if (result) {\n      this.count++;\n    }\n  }\n\n  protected _complete(): void {\n    this.destination.next(this.count);\n    this.destination.complete();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SubscribableOrPromise, TeardownLogic } from '../types';\n\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n\n/**\n * Emits a value from the source Observable only after a particular time span\n * determined by another Observable has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n * emission silence is determined by a second Observable.</span>\n *\n * <img src=\"./img/debounce.png\" width=\"100%\">\n *\n * `debounce` delays values emitted by the source Observable, but drops previous\n * pending delayed emissions if a new value arrives on the source Observable.\n * This operator keeps track of the most recent value from the source\n * Observable, and spawns a duration Observable by calling the\n * `durationSelector` function. The value is emitted only when the duration\n * Observable emits a value or completes, and if no other value was emitted on\n * the source Observable since the duration Observable was spawned. If a new\n * value appears before the duration Observable emits, the previous value will\n * be dropped and will not be emitted on the output Observable.\n *\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n * delay-like operator since output emissions do not necessarily occur at the\n * same time as they did on the source Observable.\n *\n * ## Example\n * Emit the most recent click after a burst of clicks\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(debounce(() => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the timeout\n * duration for each source value, returned as an Observable or a Promise.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified duration Observable returned by\n * `durationSelector`, and may drop some values if they occur too frequently.\n * @method debounce\n * @owner Observable\n */\nexport function debounce<T>(durationSelector: (value: T) => SubscribableOrPromise<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new DebounceOperator(durationSelector));\n}\n\nclass DebounceOperator<T> implements Operator<T, T> {\n  constructor(private durationSelector: (value: T) => SubscribableOrPromise<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DebounceSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private value: T;\n  private hasValue: boolean = false;\n  private durationSubscription: Subscription = null;\n\n  constructor(destination: Subscriber<R>,\n              private durationSelector: (value: T) => SubscribableOrPromise<any>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    try {\n      const result = this.durationSelector.call(this, value);\n\n      if (result) {\n        this._tryNext(value, result);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  }\n\n  protected _complete(): void {\n    this.emitValue();\n    this.destination.complete();\n  }\n\n  private _tryNext(value: T, duration: SubscribableOrPromise<any>): void {\n    let subscription = this.durationSubscription;\n    this.value = value;\n    this.hasValue = true;\n    if (subscription) {\n      subscription.unsubscribe();\n      this.remove(subscription);\n    }\n\n    subscription = subscribeToResult(this, duration);\n    if (subscription && !subscription.closed) {\n      this.add(this.durationSubscription = subscription);\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.emitValue();\n  }\n\n  notifyComplete(): void {\n    this.emitValue();\n  }\n\n  emitValue(): void {\n    if (this.hasValue) {\n      const value = this.value;\n      const subscription = this.durationSubscription;\n      if (subscription) {\n        this.durationSubscription = null;\n        subscription.unsubscribe();\n        this.remove(subscription);\n      }\n      // This must be done *before* passing the value\n      // along to the destination because it's possible for\n      // the value to synchronously re-enter this operator\n      // recursively if the duration selector Observable\n      // emits synchronously\n      this.value = null;\n      this.hasValue = false;\n      super._next(value);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { async } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * ## Example\n * Emit the most recent click after a burst of clicks\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(debounceTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nexport function debounceTime<T>(dueTime: number, scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new DebounceTimeOperator(dueTime, scheduler));\n}\n\nclass DebounceTimeOperator<T> implements Operator<T, T> {\n  constructor(private dueTime: number, private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DebounceTimeSubscriber<T> extends Subscriber<T> {\n  private debouncedSubscription: Subscription = null;\n  private lastValue: T = null;\n  private hasValue: boolean = false;\n\n  constructor(destination: Subscriber<T>,\n              private dueTime: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    this.clearDebounce();\n    this.lastValue = value;\n    this.hasValue = true;\n    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n  }\n\n  protected _complete() {\n    this.debouncedNext();\n    this.destination.complete();\n  }\n\n  debouncedNext(): void {\n    this.clearDebounce();\n\n    if (this.hasValue) {\n      const { lastValue } = this;\n      // This must be done *before* passing the value\n      // along to the destination because it's possible for\n      // the value to synchronously re-enter this operator\n      // recursively when scheduled with things like\n      // VirtualScheduler/TestScheduler.\n      this.lastValue = null;\n      this.hasValue = false;\n      this.destination.next(lastValue);\n    }\n  }\n\n  private clearDebounce(): void {\n    const debouncedSubscription = this.debouncedSubscription;\n\n    if (debouncedSubscription !== null) {\n      this.remove(debouncedSubscription);\n      debouncedSubscription.unsubscribe();\n      this.debouncedSubscription = null;\n    }\n  }\n}\n\nfunction dispatchNext(subscriber: DebounceTimeSubscriber<any>) {\n  subscriber.debouncedNext();\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function defaultIfEmpty<T>(defaultValue?: T): MonoTypeOperatorFunction<T>;\nexport function defaultIfEmpty<T, R>(defaultValue?: R): OperatorFunction<T, T | R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Emits a given value if the source Observable completes without emitting any\n * `next` value, otherwise mirrors the source Observable.\n *\n * <span class=\"informal\">If the source Observable turns out to be empty, then\n * this operator will emit a default value.</span>\n *\n * <img src=\"./img/defaultIfEmpty.png\" width=\"100%\">\n *\n * `defaultIfEmpty` emits the values emitted by the source Observable or a\n * specified default value if the source Observable is empty (completes without\n * having emitted any `next` value).\n *\n * ## Example\n * If no clicks happen in 5 seconds, then emit \"no clicks\"\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const clicksBeforeFive = clicks.pipe(takeUntil(interval(5000)));\n * const result = clicksBeforeFive.pipe(defaultIfEmpty('no clicks'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link empty}\n * @see {@link last}\n *\n * @param {any} [defaultValue=null] The default value used if the source\n * Observable is empty.\n * @return {Observable} An Observable that emits either the specified\n * `defaultValue` if the source Observable emits no items, or the values emitted\n * by the source Observable.\n * @method defaultIfEmpty\n * @owner Observable\n */\nexport function defaultIfEmpty<T, R>(defaultValue: R = null): OperatorFunction<T, T | R> {\n  return (source: Observable<T>) => source.lift(new DefaultIfEmptyOperator(defaultValue)) as Observable<T | R>;\n}\n\nclass DefaultIfEmptyOperator<T, R> implements Operator<T, T | R> {\n\n  constructor(private defaultValue: R) {\n  }\n\n  call(subscriber: Subscriber<T | R>, source: any): any {\n    return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DefaultIfEmptySubscriber<T, R> extends Subscriber<T> {\n  private isEmpty: boolean = true;\n\n  constructor(destination: Subscriber<T | R>, private defaultValue: R) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    this.isEmpty = false;\n    this.destination.next(value);\n  }\n\n  protected _complete(): void {\n    if (this.isEmpty) {\n      this.destination.next(this.defaultValue);\n    }\n    this.destination.complete();\n  }\n}\n","import { async } from '../scheduler/async';\nimport { isDate } from '../util/isDate';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, PartialObserver, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * <img src=\"./img/delay.png\" width=\"100%\">\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * ## Examples\n * Delay each click by one second\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const delayedClicks = clicks.pipe(delay(1000)); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * Delay all clicks until a future date happens\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const date = new Date('March 15, 2050 12:00:00'); // in the future\n * const delayedClicks = clicks.pipe(delay(date)); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {Scheduler} [scheduler=async] The IScheduler to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nexport function delay<T>(delay: number|Date,\n                         scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> {\n  const absoluteDelay = isDate(delay);\n  const delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(<number>delay);\n  return (source: Observable<T>) => source.lift(new DelayOperator(delayFor, scheduler));\n}\n\nclass DelayOperator<T> implements Operator<T, T> {\n  constructor(private delay: number,\n              private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n  }\n}\n\ninterface DelayState<T> {\n  source: DelaySubscriber<T>;\n  destination: PartialObserver<T>;\n  scheduler: SchedulerLike;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DelaySubscriber<T> extends Subscriber<T> {\n  private queue: Array<DelayMessage<T>> = [];\n  private active: boolean = false;\n  private errored: boolean = false;\n\n  private static dispatch<T>(this: SchedulerAction<DelayState<T>>, state: DelayState<T>): void {\n    const source = state.source;\n    const queue = source.queue;\n    const scheduler = state.scheduler;\n    const destination = state.destination;\n\n    while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {\n      queue.shift().notification.observe(destination);\n    }\n\n    if (queue.length > 0) {\n      const delay = Math.max(0, queue[0].time - scheduler.now());\n      this.schedule(state, delay);\n    } else {\n      this.unsubscribe();\n      source.active = false;\n    }\n  }\n\n  constructor(destination: Subscriber<T>,\n              private delay: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n  }\n\n  private _schedule(scheduler: SchedulerLike): void {\n    this.active = true;\n    this.add(scheduler.schedule<DelayState<T>>(DelaySubscriber.dispatch, this.delay, {\n      source: this, destination: this.destination, scheduler: scheduler\n    }));\n  }\n\n  private scheduleNotification(notification: Notification<T>): void {\n    if (this.errored === true) {\n      return;\n    }\n\n    const scheduler = this.scheduler;\n    const message = new DelayMessage(scheduler.now() + this.delay, notification);\n    this.queue.push(message);\n\n    if (this.active === false) {\n      this._schedule(scheduler);\n    }\n  }\n\n  protected _next(value: T) {\n    this.scheduleNotification(Notification.createNext(value));\n  }\n\n  protected _error(err: any) {\n    this.errored = true;\n    this.queue = [];\n    this.destination.error(err);\n  }\n\n  protected _complete() {\n    this.scheduleNotification(Notification.createComplete());\n  }\n}\n\nclass DelayMessage<T> {\n  constructor(public readonly time: number,\n              public readonly notification: Notification<T>) {\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/* tslint:disable:max-line-length */\n/** @deprecated In future versions, empty notifiers will no longer re-emit the source value on the output observable. */\nexport function delayWhen<T>(delayDurationSelector: (value: T) => Observable<never>, subscriptionDelay?: Observable<any>): MonoTypeOperatorFunction<T>;\nexport function delayWhen<T>(delayDurationSelector: (value: T) => Observable<any>, subscriptionDelay?: Observable<any>): MonoTypeOperatorFunction<T>;\n/* tslint:disable:max-line-length */\n\n/**\n * Delays the emission of items from the source Observable by a given time span\n * determined by the emissions of another Observable.\n *\n * <span class=\"informal\">It's like {@link delay}, but the time span of the\n * delay duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/delayWhen.png\" width=\"100%\">\n *\n * `delayWhen` time shifts each emitted value from the source Observable by a\n * time span determined by another Observable. When the source emits a value,\n * the `delayDurationSelector` function is called with the source value as\n * argument, and should return an Observable, called the \"duration\" Observable.\n * The source value is emitted on the output Observable only when the duration\n * Observable emits a value or completes.\n * The completion of the notifier triggering the emission of the source value\n * is deprecated behavior and will be removed in future versions.\n *\n * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n * is an Observable. When `subscriptionDelay` emits its first value or\n * completes, the source Observable is subscribed to and starts behaving like\n * described in the previous paragraph. If `subscriptionDelay` is not provided,\n * `delayWhen` will subscribe to the source Observable as soon as the output\n * Observable is subscribed.\n *\n * ## Example\n * Delay each click by a random amount of time, between 0 and 5 seconds\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const delayedClicks = clicks.pipe(\n *   delayWhen(event => interval(Math.random() * 5000)),\n * );\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link debounce}\n * @see {@link delay}\n *\n * @param {function(value: T): Observable} delayDurationSelector A function that\n * returns an Observable for each value emitted by the source Observable, which\n * is then used to delay the emission of that item on the output Observable\n * until the Observable returned from this function emits a value.\n * @param {Observable} subscriptionDelay An Observable that triggers the\n * subscription to the source Observable once it emits any value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by an amount of time specified by the Observable returned by\n * `delayDurationSelector`.\n * @method delayWhen\n * @owner Observable\n */\nexport function delayWhen<T>(delayDurationSelector: (value: T) => Observable<any>,\n                             subscriptionDelay?: Observable<any>): MonoTypeOperatorFunction<T> {\n  if (subscriptionDelay) {\n    return (source: Observable<T>) =>\n      new SubscriptionDelayObservable(source, subscriptionDelay)\n        .lift(new DelayWhenOperator(delayDurationSelector));\n  }\n  return (source: Observable<T>) => source.lift(new DelayWhenOperator(delayDurationSelector));\n}\n\nclass DelayWhenOperator<T> implements Operator<T, T> {\n  constructor(private delayDurationSelector: (value: T) => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DelayWhenSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private completed: boolean = false;\n  private delayNotifierSubscriptions: Array<Subscription> = [];\n\n  constructor(destination: Subscriber<T>,\n              private delayDurationSelector: (value: T) => Observable<any>) {\n    super(destination);\n  }\n\n  notifyNext(outerValue: T, innerValue: any,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.destination.next(outerValue);\n    this.removeSubscription(innerSub);\n    this.tryComplete();\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, R>): void {\n    this._error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, R>): void {\n    const value = this.removeSubscription(innerSub);\n    if (value) {\n      this.destination.next(value);\n    }\n    this.tryComplete();\n  }\n\n  protected _next(value: T): void {\n    try {\n      const delayNotifier = this.delayDurationSelector(value);\n      if (delayNotifier) {\n        this.tryDelay(delayNotifier, value);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  }\n\n  protected _complete(): void {\n    this.completed = true;\n    this.tryComplete();\n  }\n\n  private removeSubscription(subscription: InnerSubscriber<T, R>): T {\n    subscription.unsubscribe();\n\n    const subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);\n    if (subscriptionIdx !== -1) {\n      this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);\n    }\n\n    return subscription.outerValue;\n  }\n\n  private tryDelay(delayNotifier: Observable<any>, value: T): void {\n    const notifierSubscription = subscribeToResult(this, delayNotifier, value);\n\n    if (notifierSubscription && !notifierSubscription.closed) {\n      this.add(notifierSubscription);\n      this.delayNotifierSubscriptions.push(notifierSubscription);\n    }\n  }\n\n  private tryComplete(): void {\n    if (this.completed && this.delayNotifierSubscriptions.length === 0) {\n      this.destination.complete();\n    }\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SubscriptionDelayObservable<T> extends Observable<T> {\n  constructor(public source: Observable<T>, private subscriptionDelay: Observable<any>) {\n    super();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>) {\n    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SubscriptionDelaySubscriber<T> extends Subscriber<T> {\n  private sourceSubscribed: boolean = false;\n\n  constructor(private parent: Subscriber<T>, private source: Observable<T>) {\n    super();\n  }\n\n  protected _next(unused: any) {\n    this.subscribeToSource();\n  }\n\n  protected _error(err: any) {\n    this.unsubscribe();\n    this.parent.error(err);\n  }\n\n  protected _complete() {\n    this.subscribeToSource();\n  }\n\n  private subscribeToSource(): void {\n    if (!this.sourceSubscribed) {\n      this.sourceSubscribed = true;\n      this.unsubscribe();\n      this.source.subscribe(this.parent);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction, MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function filter<T, S extends T>(predicate: (value: T, index: number) => value is S,\n                                       thisArg?: any): OperatorFunction<T, S>;\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * ## Example\n * Emit only click events whose target was a DIV element\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const clicksOnDivs = clicks.pipe(filter(ev => ev.target.tagName === 'DIV'));\n * clicksOnDivs.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T> {\n  return function filterOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new FilterOperator(predicate, thisArg));\n  };\n}\n\nclass FilterOperator<T> implements Operator<T, T> {\n  constructor(private predicate: (value: T, index: number) => boolean,\n              private thisArg?: any) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass FilterSubscriber<T> extends Subscriber<T> {\n\n  count: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number) => boolean,\n              private thisArg: any) {\n    super(destination);\n  }\n\n  // the try catch block below is left specifically for\n  // optimization and perf reasons. a tryCatcher is not necessary here.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.predicate.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    if (result) {\n      this.destination.next(value);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nimport { OperatorFunction } from '../types';\n\n/**\n * Converts an Observable of {@link Notification} objects into the emissions\n * that they represent.\n *\n * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n *\n * <img src=\"./img/dematerialize.png\" width=\"100%\">\n *\n * `dematerialize` is assumed to operate an Observable that only emits\n * {@link Notification} objects as `next` emissions, and does not emit any\n * `error`. Such Observable is the output of a `materialize` operation. Those\n * notifications are then unwrapped using the metadata they contain, and emitted\n * as `next`, `error`, and `complete` on the output Observable.\n *\n * Use this operator in conjunction with {@link materialize}.\n *\n * ## Example\n * Convert an Observable of Notifications to an actual Observable\n * ```javascript\n * const notifA = new Rx.Notification('N', 'A');\n * const notifB = new Rx.Notification('N', 'B');\n * const notifE = new Rx.Notification('E', void 0,\n *   new TypeError('x.toUpperCase is not a function')\n * );\n * const materialized = of(notifA, notifB, notifE);\n * const upperCase = materialized.pipe(dematerialize());\n * upperCase.subscribe(x => console.log(x), e => console.error(e));\n *\n * // Results in:\n * // A\n * // B\n * // TypeError: x.toUpperCase is not a function\n * ```\n *\n * @see {@link Notification}\n * @see {@link materialize}\n *\n * @return {Observable} An Observable that emits items and notifications\n * embedded in Notification objects emitted by the source Observable.\n * @method dematerialize\n * @owner Observable\n */\nexport function dematerialize<T>(): OperatorFunction<Notification<T>, T> {\n  return function dematerializeOperatorFunction(source: Observable<Notification<T>>) {\n    return source.lift(new DeMaterializeOperator());\n  };\n}\n\nclass DeMaterializeOperator<T extends Notification<any>, R> implements Operator<T, R> {\n  call(subscriber: Subscriber<any>, source: any): any {\n    return source.subscribe(new DeMaterializeSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DeMaterializeSubscriber<T extends Notification<any>> extends Subscriber<T> {\n  constructor(destination: Subscriber<any>) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    value.observe(this.destination);\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n *\n * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\n * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\n * source observable directly with an equality check against previous values.\n *\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n *\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\n *\n * ## Examples\n * A simple example with numbers\n * ```javascript\n * of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1).pipe(\n *     distinct(),\n *   )\n *   .subscribe(x => console.log(x)); // 1, 2, 3, 4\n * ```\n *\n * An example using a keySelector function\n * ```typescript\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'},\n *   ).pipe(\n *     distinct((p: Person) => p.name),\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * ```\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [keySelector] Optional function to select which value you want to check as distinct.\n * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinct\n * @owner Observable\n */\nexport function distinct<T, K>(keySelector?: (value: T) => K,\n                               flushes?: Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new DistinctOperator(keySelector, flushes));\n}\n\nclass DistinctOperator<T, K> implements Operator<T, T> {\n  constructor(private keySelector: (value: T) => K, private flushes: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class DistinctSubscriber<T, K> extends OuterSubscriber<T, T> {\n  private values = new Set<K>();\n\n  constructor(destination: Subscriber<T>, private keySelector: (value: T) => K, flushes: Observable<any>) {\n    super(destination);\n\n    if (flushes) {\n      this.add(subscribeToResult(this, flushes));\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: T,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, T>): void {\n    this.values.clear();\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, T>): void {\n    this._error(error);\n  }\n\n  protected _next(value: T): void {\n    if (this.keySelector) {\n      this._useKeySelector(value);\n    } else {\n      this._finalizeNext(value, value);\n    }\n  }\n\n  private _useKeySelector(value: T): void {\n    let key: K;\n    const { destination } = this;\n    try {\n      key = this.keySelector(value);\n    } catch (err) {\n      destination.error(err);\n      return;\n    }\n    this._finalizeNext(key, value);\n  }\n\n  private _finalizeNext(key: K|T, value: T) {\n    const { values } = this;\n    if (!values.has(<K>key)) {\n      values.add(<K>key);\n      this.destination.next(value);\n    }\n  }\n\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function distinctUntilChanged<T>(compare?: (x: T, y: T) => boolean): MonoTypeOperatorFunction<T>;\nexport function distinctUntilChanged<T, K>(compare: (x: K, y: K) => boolean, keySelector: (x: T) => K): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * ## Example\n * A simple example with numbers\n * ```javascript\n * of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4).pipe(\n *     distinctUntilChanged(),\n *   )\n *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4\n * ```\n *\n * An example using a compare function\n * ```typescript\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'},\n *     { age: 6, name: 'Foo'},\n *   ).pipe(\n *     distinctUntilChanged((p: Person, q: Person) => p.name === q.name),\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinctUntilChanged\n * @owner Observable\n */\nexport function distinctUntilChanged<T, K>(compare?: (x: K, y: K) => boolean, keySelector?: (x: T) => K): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new DistinctUntilChangedOperator<T, K>(compare, keySelector));\n}\n\nclass DistinctUntilChangedOperator<T, K> implements Operator<T, T> {\n  constructor(private compare: (x: K, y: K) => boolean,\n              private keySelector: (x: T) => K) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DistinctUntilChangedSubscriber<T, K> extends Subscriber<T> {\n  private key: K;\n  private hasKey: boolean = false;\n\n  constructor(destination: Subscriber<T>,\n              compare: (x: K, y: K) => boolean,\n              private keySelector: (x: T) => K) {\n    super(destination);\n    if (typeof compare === 'function') {\n      this.compare = compare;\n    }\n  }\n\n  private compare(x: any, y: any): boolean {\n    return x === y;\n  }\n\n  protected _next(value: T): void {\n\n    const keySelector = this.keySelector;\n    let key: any = value;\n\n    if (keySelector) {\n      key = tryCatch(this.keySelector)(value);\n      if (key === errorObject) {\n        return this.destination.error(errorObject.e);\n      }\n    }\n\n    let result: any = false;\n\n    if (this.hasKey) {\n      result = tryCatch(this.compare)(this.key, key);\n      if (result === errorObject) {\n        return this.destination.error(errorObject.e);\n      }\n    } else {\n      this.hasKey = true;\n    }\n\n    if (Boolean(result) === false) {\n      this.key = key;\n      this.destination.next(value);\n    }\n  }\n}\n","/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\nexport class ArgumentOutOfRangeError extends Error {\n\n  public readonly name = 'ArgumentOutOfRangeError';\n\n  constructor() {\n    super('argument out of range');\n    (Object as any).setPrototypeOf(this, ArgumentOutOfRangeError.prototype);\n  }\n}\n","/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n *\n * @class EmptyError\n */\nexport class EmptyError extends Error {\n\n  public readonly name = 'EmptyError';\n\n  constructor() {\n    super('no elements in sequence');\n    (Object as any).setPrototypeOf(this, EmptyError.prototype);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, PartialObserver, TeardownLogic } from '../types';\nimport { noop } from '../util/noop';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\nexport function tap<T>(next?: (x: T) => void, error?: (e: any) => void, complete?: () => void): MonoTypeOperatorFunction<T>;\nexport function tap<T>(observer: PartialObserver<T>): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `tap` is not subscribed, the side effects specified by the\n * Observer will never happen. `tap` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * ## Example\n * Map every click to the clientX position of that click, while also logging the click event\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const positions = clicks.pipe(\n *   tap(ev => console.log(ev)),\n *   map(ev => ev.clientX),\n * );\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nexport function tap<T>(nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n                       error?: (e: any) => void,\n                       complete?: () => void): MonoTypeOperatorFunction<T> {\n  return function tapOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new DoOperator(nextOrObserver, error, complete));\n  };\n}\n\nclass DoOperator<T> implements Operator<T, T> {\n  constructor(private nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n              private error?: (e: any) => void,\n              private complete?: () => void) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nclass TapSubscriber<T> extends Subscriber<T> {\n  private _context: any;\n\n  private _tapNext: ((value: T) => void) = noop;\n\n  private _tapError: ((err: any) => void) = noop;\n\n  private _tapComplete: (() => void) = noop;\n\n  constructor(destination: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n      super(destination);\n      this._tapError = error || noop;\n      this._tapComplete = complete || noop;\n      if (isFunction(observerOrNext)) {\n        this._context = this;\n        this._tapNext = observerOrNext;\n      } else if (observerOrNext) {\n        this._context = observerOrNext;\n        this._tapNext = observerOrNext.next || noop;\n        this._tapError = observerOrNext.error || noop;\n        this._tapComplete = observerOrNext.complete || noop;\n      }\n    }\n\n  _next(value: T) {\n    try {\n      this._tapNext.call(this._context, value);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(value);\n  }\n\n  _error(err: any) {\n    try {\n      this._tapError.call(this._context, err);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.error(err);\n  }\n\n  _complete() {\n    try {\n      this._tapComplete.call(this._context, );\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    return this.destination.complete();\n  }\n}\n","/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport class ObjectUnsubscribedError extends Error {\n\n  public readonly name = 'ObjectUnsubscribedError';\n\n  constructor() {\n    super('object unsubscribed');\n    (Object as any).setPrototypeOf(this, ObjectUnsubscribedError.prototype);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { empty } from '../observable/empty';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * <img src=\"./img/take.png\" width=\"100%\">\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * ## Example\n * Take the first 5 seconds of an infinite 1-second interval Observable\n * ```javascript\n * const interval = interval(1000);\n * const five = interval.pipe(take(5));\n * five.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nexport function take<T>(count: number): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => {\n    if (count === 0) {\n      return empty();\n    } else {\n      return source.lift(new TakeOperator(count));\n    }\n  };\n}\n\nclass TakeOperator<T> implements Operator<T, T> {\n  constructor(private total: number) {\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError;\n    }\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TakeSubscriber(subscriber, this.total));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeSubscriber<T> extends Subscriber<T> {\n  private count: number = 0;\n\n  constructor(destination: Subscriber<T>, private total: number) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const total = this.total;\n    const count = ++this.count;\n    if (count <= total) {\n      this.destination.next(value);\n      if (count === total) {\n        this.destination.complete();\n        this.unsubscribe();\n      }\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Observer, OperatorFunction } from '../types';\n\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n *\n * ## Example\n * A simple example emitting true if all elements are less than 5, false otherwise\n * ```javascript\n *  of(1, 2, 3, 4, 5, 6).pipe(\n *     every(x => x < 5),\n * )\n * .subscribe(x => console.log(x)); // -> false\n * ```\n *\n * @param {function} predicate A function for determining if an item meets a specified condition.\n * @param {any} [thisArg] Optional object to use for `this` in the callback.\n * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.\n * @method every\n * @owner Observable\n */\nexport function every<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                         thisArg?: any): OperatorFunction<T, boolean> {\n  return (source: Observable<T>) => source.lift(new EveryOperator(predicate, thisArg, source));\n}\n\nclass EveryOperator<T> implements Operator<T, boolean> {\n  constructor(private predicate: (value: T, index: number, source: Observable<T>) => boolean,\n              private thisArg?: any,\n              private source?: Observable<T>) {\n  }\n\n  call(observer: Subscriber<boolean>, source: any): any {\n    return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass EverySubscriber<T> extends Subscriber<T> {\n  private index: number = 0;\n\n  constructor(destination: Observer<boolean>,\n              private predicate: (value: T, index: number, source: Observable<T>) => boolean,\n              private thisArg: any,\n              private source?: Observable<T>) {\n    super(destination);\n    this.thisArg = thisArg || this;\n  }\n\n  private notifyComplete(everyValueMatch: boolean): void {\n    this.destination.next(everyValueMatch);\n    this.destination.complete();\n  }\n\n  protected _next(value: T): void {\n    let result = false;\n    try {\n      result = this.predicate.call(this.thisArg, value, this.index++, this.source);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    if (!result) {\n      this.notifyComplete(false);\n    }\n  }\n\n  protected _complete(): void {\n    this.notifyComplete(true);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { ObservableInput, OperatorFunction, TeardownLogic } from '../types';\n\nexport function exhaust<T>(): OperatorFunction<ObservableInput<T>, T>;\nexport function exhaust<R>(): OperatorFunction<any, R>;\n\n/**\n * Converts a higher-order Observable into a first-order Observable by dropping\n * inner Observables while the previous inner Observable has not yet completed.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * next inner Observables while the current inner is still executing.</span>\n *\n * <img src=\"./img/exhaust.png\" width=\"100%\">\n *\n * `exhaust` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable begins emitting the items emitted by that\n * inner Observable. So far, it behaves like {@link mergeAll}. However,\n * `exhaust` ignores every new inner Observable if the previous Observable has\n * not yet completed. Once that one completes, it will accept and flatten the\n * next inner Observable and repeat this process.\n *\n * ## Example\n * Run a finite timer for each click, only if there is no currently active timer\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map((ev) => interval(1000).pipe(take(5))),\n * );\n * const result = higherOrder.pipe(exhaust());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link switch}\n * @see {@link mergeAll}\n * @see {@link exhaustMap}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable that takes a source of Observables and propagates the first observable\n * exclusively until it completes before subscribing to the next.\n * @method exhaust\n * @owner Observable\n */\nexport function exhaust<T>(): OperatorFunction<any, T> {\n  return (source: Observable<T>) => source.lift(new SwitchFirstOperator<T>());\n}\n\nclass SwitchFirstOperator<T> implements Operator<T, T> {\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SwitchFirstSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SwitchFirstSubscriber<T> extends OuterSubscriber<T, T> {\n  private hasCompleted: boolean = false;\n  private hasSubscription: boolean = false;\n\n  constructor(destination: Subscriber<T>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (!this.hasSubscription) {\n      this.hasSubscription = true;\n      this.add(subscribeToResult(this, value));\n    }\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (!this.hasSubscription) {\n      this.destination.complete();\n    }\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    this.remove(innerSub);\n    this.hasSubscription = false;\n    if (this.hasCompleted) {\n      this.destination.complete();\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { map } from './map';\nimport { from } from '../observable/from';\n\n/* tslint:disable:max-line-length */\nexport function exhaustMap<T, R>(project: (value: T, index: number) => ObservableInput<R>): OperatorFunction<T, R>;\n/** @deprecated resultSelector is no longer supported. Use inner map instead. */\nexport function exhaustMap<T, R>(project: (value: T, index: number) => ObservableInput<R>, resultSelector: undefined): OperatorFunction<T, R>;\n/** @deprecated resultSelector is no longer supported. Use inner map instead. */\nexport function exhaustMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * ## Example\n * Run a finite timer for each click, only if there is no currently active timer\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   exhaustMap((ev) => interval(1000).pipe(take(5))),\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\nexport function exhaustMap<T, I, R>(\n  project: (value: T, index: number) => ObservableInput<I>,\n  resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R,\n): OperatorFunction<T, I|R> {\n  if (resultSelector) {\n    // DEPRECATED PATH\n    return (source: Observable<T>) => source.pipe(\n      exhaustMap((a, i) => from(project(a, i)).pipe(\n        map((b, ii) => resultSelector(a, b, i, ii)),\n      )),\n    );\n  }\n  return (source: Observable<T>) =>\n    source.lift(new ExhauseMapOperator(project));\n}\n\nclass ExhauseMapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => ObservableInput<R>) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ExhaustMapSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private hasSubscription = false;\n  private hasCompleted = false;\n  private index = 0;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => ObservableInput<R>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (!this.hasSubscription) {\n      this.tryNext(value);\n    }\n  }\n\n  private tryNext(value: T): void {\n    const index = this.index++;\n    const destination = this.destination;\n    try {\n      const result = this.project(value, index);\n      this.hasSubscription = true;\n      this.add(subscribeToResult(this, result, value, index));\n    } catch (err) {\n      destination.error(err);\n    }\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (!this.hasSubscription) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.destination.next(innerValue);\n  }\n\n  notifyError(err: any): void {\n    this.destination.error(err);\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    this.remove(innerSub);\n\n    this.hasSubscription = false;\n    if (this.hasCompleted) {\n      this.destination.complete();\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { MonoTypeOperatorFunction, OperatorFunction, ObservableInput, SchedulerLike } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function expand<T, R>(project: (value: T, index: number) => ObservableInput<R>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, R>;\nexport function expand<T>(project: (value: T, index: number) => ObservableInput<T>, concurrent?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * <img src=\"./img/expand.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * ## Example\n * Start emitting the powers of two on every click, at most 10 of them\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const powersOfTwo = clicks.pipe(\n *   mapTo(1),\n *   expand(x => of(2 * x).pipe(delay(1000))),\n *   take(10),\n * );\n * powersOfTwo.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each projected inner Observable.\n * @return {Observable} An Observable that emits the source values and also\n * result of applying the projection function to each value emitted on the\n * output Observable and and merging the results of the Observables obtained\n * from this transformation.\n * @method expand\n * @owner Observable\n */\nexport function expand<T, R>(project: (value: T, index: number) => ObservableInput<R>,\n                             concurrent: number = Number.POSITIVE_INFINITY,\n                             scheduler: SchedulerLike = undefined): OperatorFunction<T, R> {\n  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n\n  return (source: Observable<T>) => source.lift(new ExpandOperator(project, concurrent, scheduler));\n}\n\nexport class ExpandOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => ObservableInput<R>,\n              private concurrent: number,\n              private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n  }\n}\n\ninterface DispatchArg<T, R> {\n  subscriber: ExpandSubscriber<T, R>;\n  result: ObservableInput<R>;\n  value: any;\n  index: number;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class ExpandSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private index: number = 0;\n  private active: number = 0;\n  private hasCompleted: boolean = false;\n  private buffer: any[];\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => ObservableInput<R>,\n              private concurrent: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n    if (concurrent < Number.POSITIVE_INFINITY) {\n      this.buffer = [];\n    }\n  }\n\n  private static dispatch<T, R>(arg: DispatchArg<T, R>): void {\n    const {subscriber, result, value, index} = arg;\n    subscriber.subscribeToProjection(result, value, index);\n  }\n\n  protected _next(value: any): void {\n    const destination = this.destination;\n\n    if (destination.closed) {\n      this._complete();\n      return;\n    }\n\n    const index = this.index++;\n    if (this.active < this.concurrent) {\n      destination.next(value);\n      let result = tryCatch(this.project)(value, index);\n      if (result === errorObject) {\n        destination.error(errorObject.e);\n      } else if (!this.scheduler) {\n        this.subscribeToProjection(result, value, index);\n      } else {\n        const state: DispatchArg<T, R> = { subscriber: this, result, value, index };\n        this.add(this.scheduler.schedule<DispatchArg<T, R>>(ExpandSubscriber.dispatch, 0, state));\n      }\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  private subscribeToProjection(result: any, value: T, index: number): void {\n    this.active++;\n    this.add(subscribeToResult<T, R>(this, result, value, index));\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this._next(innerValue);\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    const buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n    if (buffer && buffer.length > 0) {\n      this._next(buffer.shift());\n    }\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete();\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * @param {function} callback Function to be called when source terminates.\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @owner Observable\n */\nexport function finalize<T>(callback: () => void): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new FinallyOperator(callback));\n}\n\nclass FinallyOperator<T> implements Operator<T, T> {\n  constructor(private callback: () => void) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new FinallySubscriber(subscriber, this.callback));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass FinallySubscriber<T> extends Subscriber<T> {\n  constructor(destination: Subscriber<T>, callback: () => void) {\n    super(destination);\n    this.add(new Subscription(callback));\n  }\n}\n","import {Observable} from '../Observable';\nimport {Operator} from '../Operator';\nimport {Subscriber} from '../Subscriber';\nimport {OperatorFunction, MonoTypeOperatorFunction} from '../types';\n\nexport function find<T, S extends T>(predicate: (value: T, index: number, source: Observable<T>) => value is S,\n                                     thisArg?: any): OperatorFunction<T, S>;\nexport function find<T, S extends T>(predicate: (value: T, index: number) => value is S,\n                                     thisArg?: any): OperatorFunction<T, S>;\nexport function find<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                        thisArg?: any): MonoTypeOperatorFunction<T>;\nexport function find<T>(predicate: (value: T, index: number) => boolean,\n                        thisArg?: any): MonoTypeOperatorFunction<T>;\n/**\n * Emits only the first value emitted by the source Observable that meets some\n * condition.\n *\n * <span class=\"informal\">Finds the first value that passes some test and emits\n * that.</span>\n *\n * <img src=\"./img/find.png\" width=\"100%\">\n *\n * `find` searches for the first item in the source Observable that matches the\n * specified condition embodied by the `predicate`, and returns the first\n * occurrence in the source. Unlike {@link first}, the `predicate` is required\n * in `find`, and does not emit an error if a valid value is not found.\n *\n * ## Example\n * Find and emit the first click that happens on a DIV element\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(find(ev => ev.target.tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link first}\n * @see {@link findIndex}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable<T>} An Observable of the first item that matches the\n * condition.\n * @method find\n * @owner Observable\n */\nexport function find<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                        thisArg?: any): MonoTypeOperatorFunction<T> {\n  if (typeof predicate !== 'function') {\n    throw new TypeError('predicate is not a function');\n  }\n  return (source: Observable<T>) => source.lift(new FindValueOperator(predicate, source, false, thisArg));\n}\n\nexport class FindValueOperator<T> implements Operator<T, T> {\n  constructor(private predicate: (value: T, index: number, source: Observable<T>) => boolean,\n              private source: Observable<T>,\n              private yieldIndex: boolean,\n              private thisArg?: any) {\n  }\n\n  call(observer: Subscriber<T>, source: any): any {\n    return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class FindValueSubscriber<T> extends Subscriber<T> {\n  private index: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number, source: Observable<T>) => boolean,\n              private source: Observable<T>,\n              private yieldIndex: boolean,\n              private thisArg?: any) {\n    super(destination);\n  }\n\n  private notifyComplete(value: any): void {\n    const destination = this.destination;\n\n    destination.next(value);\n    destination.complete();\n  }\n\n  protected _next(value: T): void {\n    const {predicate, thisArg} = this;\n    const index = this.index++;\n    try {\n      const result = predicate.call(thisArg || this, value, index, this.source);\n      if (result) {\n        this.notifyComplete(this.yieldIndex ? index : value);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  }\n\n  protected _complete(): void {\n    this.notifyComplete(this.yieldIndex ? -1 : undefined);\n  }\n}\n","import { Subject } from './Subject';\nimport { Observer } from './types';\nimport { Subscription } from './Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class SubjectSubscription<T> extends Subscription {\n  closed: boolean = false;\n\n  constructor(public subject: Subject<T>, public subscriber: Observer<T>) {\n    super();\n  }\n\n  unsubscribe() {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n\n    const subject = this.subject;\n    const observers = subject.observers;\n\n    this.subject = null;\n\n    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n      return;\n    }\n\n    const subscriberIndex = observers.indexOf(this.subscriber);\n\n    if (subscriberIndex !== -1) {\n      observers.splice(subscriberIndex, 1);\n    }\n  }\n}\n","import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\n\n/**\n * @class SubjectSubscriber<T>\n */\nexport class SubjectSubscriber<T> extends Subscriber<T> {\n  constructor(protected destination: Subject<T>) {\n    super(destination);\n  }\n}\n\n/**\n * @class Subject<T>\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n\n  [rxSubscriberSymbol]() {\n    return new SubjectSubscriber(this);\n  }\n\n  observers: Observer<T>[] = [];\n\n  closed = false;\n\n  isStopped = false;\n\n  hasError = false;\n\n  thrownError: any = null;\n\n  constructor() {\n    super();\n  }\n\n  /**@nocollapse */\n  static create: Function = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  }\n\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = <any>operator;\n    return <any>subject;\n  }\n\n  next(value?: T) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    if (!this.isStopped) {\n      const { observers } = this;\n      const len = observers.length;\n      const copy = observers.slice();\n      for (let i = 0; i < len; i++) {\n        copy[i].next(value);\n      }\n    }\n  }\n\n  error(err: any) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    this.hasError = true;\n    this.thrownError = err;\n    this.isStopped = true;\n    const { observers } = this;\n    const len = observers.length;\n    const copy = observers.slice();\n    for (let i = 0; i < len; i++) {\n      copy[i].error(err);\n    }\n    this.observers.length = 0;\n  }\n\n  complete() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    this.isStopped = true;\n    const { observers } = this;\n    const len = observers.length;\n    const copy = observers.slice();\n    for (let i = 0; i < len; i++) {\n      copy[i].complete();\n    }\n    this.observers.length = 0;\n  }\n\n  unsubscribe() {\n    this.isStopped = true;\n    this.closed = true;\n    this.observers = null;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else {\n      return super._trySubscribe(subscriber);\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.hasError) {\n      subscriber.error(this.thrownError);\n      return Subscription.EMPTY;\n    } else if (this.isStopped) {\n      subscriber.complete();\n      return Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      return new SubjectSubscription(this, subscriber);\n    }\n  }\n\n  asObservable(): Observable<T> {\n    const observable = new Observable<T>();\n    (<any>observable).source = this;\n    return observable;\n  }\n}\n\n/**\n * @class AnonymousSubject<T>\n */\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(protected destination?: Observer<T>, source?: Observable<T>) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    const { destination } = this;\n    if (destination && destination.next) {\n      destination.next(value);\n    }\n  }\n\n  error(err: any) {\n    const { destination } = this;\n    if (destination && destination.error) {\n      this.destination.error(err);\n    }\n  }\n\n  complete() {\n    const { destination } = this;\n    if (destination && destination.complete) {\n      this.destination.complete();\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    const { source } = this;\n    if (source) {\n      return this.source.subscribe(subscriber);\n    } else {\n      return Subscription.EMPTY;\n    }\n  }\n}\n","import { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subject } from '../Subject';\nimport { OperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function groupBy<T, K>(keySelector: (value: T) => K): OperatorFunction<T, GroupedObservable<K, T>>;\nexport function groupBy<T, K>(keySelector: (value: T) => K, elementSelector: void, durationSelector: (grouped: GroupedObservable<K, T>) => Observable<any>): OperatorFunction<T, GroupedObservable<K, T>>;\nexport function groupBy<T, K, R>(keySelector: (value: T) => K, elementSelector?: (value: T) => R, durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>): OperatorFunction<T, GroupedObservable<K, R>>;\nexport function groupBy<T, K, R>(keySelector: (value: T) => K, elementSelector?: (value: T) => R, durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>, subjectSelector?: () => Subject<R>): OperatorFunction<T, GroupedObservable<K, R>>;\n/* tslint:enable:max-line-length */\n\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * <img src=\"./img/groupBy.png\" width=\"100%\">\n *\n * ##Examples\n * Group objects by id and return as array\n * ```javascript\n * of<Obj>(\n *   {id: 1, name: 'aze1'},\n *   {id: 2, name: 'sf2'},\n *   {id: 2, name: 'dg2'},\n *   {id: 1, name: 'erg1'},\n *   {id: 1, name: 'df1'},\n *   {id: 2, name: 'sfqfb2'},\n *   {id: 3, name: 'qfs3'},\n *   {id: 2, name: 'qsgqsfg2'},\n * ).pipe(\n *   groupBy(p => p.id),\n *   flatMap((group$) => group$.pipe(reduce((acc, cur) => [...acc, cur], []))),\n * )\n * .subscribe(p => console.log(p));\n *\n * // displays:\n * // [ { id: 1, name: 'aze1' },\n * //   { id: 1, name: 'erg1' },\n * //   { id: 1, name: 'df1' } ]\n * //\n * // [ { id: 2, name: 'sf2' },\n * //   { id: 2, name: 'dg2' },\n * //   { id: 2, name: 'sfqfb2' },\n * //   { id: 2, name: 'qsgqsfg2' } ]\n * //\n * // [ { id: 3, name: 'qfs3' } ]\n * ```\n *\n * Pivot data on the id field\n * ```javascript\n * of<Obj>(\n *   {id: 1, name: 'aze1'},\n *   {id: 2, name: 'sf2'},\n *   {id: 2, name: 'dg2'},\n *   {id: 1, name: 'erg1'},\n *   {id: 1, name: 'df1'},\n *   {id: 2, name: 'sfqfb2'},\n *   {id: 3, name: 'qfs1'},\n *   {id: 2, name: 'qsgqsfg2'},\n * ).pipe(\n *   groupBy(p => p.id, p => p.name),\n *   flatMap( (group$) => group$.pipe(reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))),\n *   map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)})),\n * )\n * .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\n * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\n * // { id: 3, values: [ 'qfs1' ] }\n * ```\n *\n * @param {function(value: T): K} keySelector A function that extracts the key\n * for each item.\n * @param {function(value: T): R} [elementSelector] A function that extracts the\n * return element for each item.\n * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @return {Observable<GroupedObservable<K,R>>} An Observable that emits\n * GroupedObservables, each of which corresponds to a unique key value and each\n * of which emits those items from the source Observable that share that key\n * value.\n * @method groupBy\n * @owner Observable\n */\nexport function groupBy<T, K, R>(keySelector: (value: T) => K,\n                                 elementSelector?: ((value: T) => R) | void,\n                                 durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>,\n                                 subjectSelector?: () => Subject<R>): OperatorFunction<T, GroupedObservable<K, R>> {\n  return (source: Observable<T>) =>\n    source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));\n}\n\nexport interface RefCountSubscription {\n  count: number;\n  unsubscribe: () => void;\n  closed: boolean;\n  attemptedToUnsubscribe: boolean;\n}\n\nclass GroupByOperator<T, K, R> implements Operator<T, GroupedObservable<K, R>> {\n  constructor(private keySelector: (value: T) => K,\n              private elementSelector?: ((value: T) => R) | void,\n              private durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>,\n              private subjectSelector?: () => Subject<R>) {\n  }\n\n  call(subscriber: Subscriber<GroupedObservable<K, R>>, source: any): any {\n    return source.subscribe(new GroupBySubscriber(\n      subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass GroupBySubscriber<T, K, R> extends Subscriber<T> implements RefCountSubscription {\n  private groups: Map<K, Subject<T | R>> = null;\n  public attemptedToUnsubscribe: boolean = false;\n  public count: number = 0;\n\n  constructor(destination: Subscriber<GroupedObservable<K, R>>,\n              private keySelector: (value: T) => K,\n              private elementSelector?: ((value: T) => R) | void,\n              private durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>,\n              private subjectSelector?: () => Subject<R>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    let key: K;\n    try {\n      key = this.keySelector(value);\n    } catch (err) {\n      this.error(err);\n      return;\n    }\n\n    this._group(value, key);\n  }\n\n  private _group(value: T, key: K) {\n    let groups = this.groups;\n\n    if (!groups) {\n      groups = this.groups = new Map<K, Subject<T | R>>();\n    }\n\n    let group = groups.get(key);\n\n    let element: R;\n    if (this.elementSelector) {\n      try {\n        element = this.elementSelector(value);\n      } catch (err) {\n        this.error(err);\n      }\n    } else {\n      element = <any>value;\n    }\n\n    if (!group) {\n      group = (this.subjectSelector ? this.subjectSelector() : new Subject<R>()) as Subject<T | R>;\n      groups.set(key, group);\n      const groupedObservable = new GroupedObservable(key, group, this);\n      this.destination.next(groupedObservable);\n      if (this.durationSelector) {\n        let duration: any;\n        try {\n          duration = this.durationSelector(new GroupedObservable<K, R>(key, <Subject<R>>group));\n        } catch (err) {\n          this.error(err);\n          return;\n        }\n        this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\n      }\n    }\n\n    if (!group.closed) {\n      group.next(element);\n    }\n  }\n\n  protected _error(err: any): void {\n    const groups = this.groups;\n    if (groups) {\n      groups.forEach((group, key) => {\n        group.error(err);\n      });\n\n      groups.clear();\n    }\n    this.destination.error(err);\n  }\n\n  protected _complete(): void {\n    const groups = this.groups;\n    if (groups) {\n      groups.forEach((group, key) => {\n        group.complete();\n      });\n\n      groups.clear();\n    }\n    this.destination.complete();\n  }\n\n  removeGroup(key: K): void {\n    this.groups.delete(key);\n  }\n\n  unsubscribe() {\n    if (!this.closed) {\n      this.attemptedToUnsubscribe = true;\n      if (this.count === 0) {\n        super.unsubscribe();\n      }\n    }\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass GroupDurationSubscriber<K, T> extends Subscriber<T> {\n  constructor(private key: K,\n              private group: Subject<T>,\n              private parent: GroupBySubscriber<any, K, T | any>) {\n    super(group);\n  }\n\n  protected _next(value: T): void {\n    this.complete();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    const { parent, key } = this;\n    this.key = this.parent = null;\n    if (parent) {\n      parent.removeGroup(key);\n    }\n  }\n}\n\n/**\n * An Observable representing values belonging to the same group represented by\n * a common key. The values emitted by a GroupedObservable come from the source\n * Observable. The common key is available as the field `key` on a\n * GroupedObservable instance.\n *\n * @class GroupedObservable<K, T>\n */\nexport class GroupedObservable<K, T> extends Observable<T> {\n  /** @deprecated Do not construct this type. Internal use only */\n  constructor(public key: K,\n              private groupSubject: Subject<T>,\n              private refCountSubscription?: RefCountSubscription) {\n    super();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>) {\n    const subscription = new Subscription();\n    const { refCountSubscription, groupSubject } = this;\n    if (refCountSubscription && !refCountSubscription.closed) {\n      subscription.add(new InnerRefCountSubscription(refCountSubscription));\n    }\n    subscription.add(groupSubject.subscribe(subscriber));\n    return subscription;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass InnerRefCountSubscription extends Subscription {\n  constructor(private parent: RefCountSubscription) {\n    super();\n    parent.count++;\n  }\n\n  unsubscribe() {\n    const parent = this.parent;\n    if (!parent.closed && !this.closed) {\n      super.unsubscribe();\n      parent.count -= 1;\n      if (parent.count === 0 && parent.attemptedToUnsubscribe) {\n        parent.unsubscribe();\n      }\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\n\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * <img src=\"./img/ignoreElements.png\" width=\"100%\">\n *\n * ## Examples\n * ### Ignores emitted values, reacts to observable's completion.\n * ```javascript\n * of('you', 'talking', 'to', 'me').pipe(\n *   ignoreElements(),\n * )\n * .subscribe(\n *   word => console.log(word),\n *   err => console.log('error:', err),\n *   () => console.log('the end'),\n * );\n * // result:\n * // 'the end'\n * ```\n * @return {Observable} An empty Observable that only calls `complete`\n * or `error`, based on which one is called by the source Observable.\n * @method ignoreElements\n * @owner Observable\n */\nexport function ignoreElements(): OperatorFunction<any, never> {\n  return function ignoreElementsOperatorFunction(source: Observable<any>) {\n    return source.lift(new IgnoreElementsOperator());\n  };\n}\n\nclass IgnoreElementsOperator<T, R> implements Operator<T, R> {\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new IgnoreElementsSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass IgnoreElementsSubscriber<T> extends Subscriber<T> {\n  protected _next(unused: T): void {\n    // Do nothing\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n\nexport function isEmpty<T>(): OperatorFunction<T, boolean> {\n  return (source: Observable<T>) => source.lift(new IsEmptyOperator());\n}\n\nclass IsEmptyOperator implements Operator<any, boolean> {\n  call (observer: Subscriber<boolean>, source: any): any {\n    return source.subscribe(new IsEmptySubscriber(observer));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass IsEmptySubscriber extends Subscriber<any> {\n  constructor(destination: Subscriber<boolean>) {\n    super(destination);\n  }\n\n  private notifyComplete(isEmpty: boolean): void {\n    const destination = this.destination;\n\n    destination.next(isEmpty);\n    destination.complete();\n  }\n\n  protected _next(value: boolean) {\n    this.notifyComplete(false);\n  }\n\n  protected _complete() {\n    this.notifyComplete(true);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { empty } from '../observable/empty';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Emits only the last `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Remembers the latest `count` values, then emits those\n * only when the source completes.</span>\n *\n * <img src=\"./img/takeLast.png\" width=\"100%\">\n *\n * `takeLast` returns an Observable that emits at most the last `count` values\n * emitted by the source Observable. If the source emits fewer than `count`\n * values then all of its values are emitted. This operator must wait until the\n * `complete` notification emission from the source in order to emit the `next`\n * values on the output Observable, because otherwise it is impossible to know\n * whether or not more values will be emitted on the source. For this reason,\n * all values are emitted synchronously, followed by the complete notification.\n *\n * ## Example\n * Take the last 3 values of an Observable with many values\n * ```javascript\n * const many = range(1, 100);\n * const lastThree = many.pipe(takeLast(3));\n * lastThree.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of values to emit from the end of\n * the sequence of values emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits at most the last count\n * values emitted by the source Observable.\n * @method takeLast\n * @owner Observable\n */\nexport function takeLast<T>(count: number): MonoTypeOperatorFunction<T> {\n  return function takeLastOperatorFunction(source: Observable<T>): Observable<T> {\n    if (count === 0) {\n      return empty();\n    } else {\n      return source.lift(new TakeLastOperator(count));\n    }\n  };\n}\n\nclass TakeLastOperator<T> implements Operator<T, T> {\n  constructor(private total: number) {\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError;\n    }\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TakeLastSubscriber(subscriber, this.total));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeLastSubscriber<T> extends Subscriber<T> {\n  private ring: Array<T> = new Array();\n  private count: number = 0;\n\n  constructor(destination: Subscriber<T>, private total: number) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const ring = this.ring;\n    const total = this.total;\n    const count = this.count++;\n\n    if (ring.length < total) {\n      ring.push(value);\n    } else {\n      const index = count % total;\n      ring[index] = value;\n    }\n  }\n\n  protected _complete(): void {\n    const destination = this.destination;\n    let count = this.count;\n\n    if (count > 0) {\n      const total = this.count >= this.total ? this.total : this.count;\n      const ring  = this.ring;\n\n      for (let i = 0; i < total; i++) {\n        const idx = (count++) % total;\n        destination.next(ring[idx]);\n      }\n    }\n\n    destination.complete();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * <img src=\"./img/mapTo.png\" width=\"100%\">\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * ## Example\n * Map every click to the string 'Hi'\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const greetings = clicks.pipe(mapTo('Hi'));\n * greetings.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\nexport function mapTo<T, R>(value: R): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift(new MapToOperator(value));\n}\n\nclass MapToOperator<T, R> implements Operator<T, R> {\n\n  value: R;\n\n  constructor(value: R) {\n    this.value = value;\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MapToSubscriber(subscriber, this.value));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MapToSubscriber<T, R> extends Subscriber<T> {\n\n  value: R;\n\n  constructor(destination: Subscriber<R>, value: R) {\n    super(destination);\n    this.value = value;\n  }\n\n  protected _next(x: T) {\n    this.destination.next(this.value);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nimport { OperatorFunction } from '../types';\n\n/**\n * Represents all of the notifications from the source Observable as `next`\n * emissions marked with their original types within {@link Notification}\n * objects.\n *\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n * {@link Notification} objects, emitted as `next` on the output Observable.\n * </span>\n *\n * <img src=\"./img/materialize.png\" width=\"100%\">\n *\n * `materialize` returns an Observable that emits a `next` notification for each\n * `next`, `error`, or `complete` emission of the source Observable. When the\n * source Observable emits `complete`, the output Observable will emit `next` as\n * a Notification of type \"complete\", and then it will emit `complete` as well.\n * When the source Observable emits `error`, the output will emit `next` as a\n * Notification of type \"error\", and then `complete`.\n *\n * This operator is useful for producing metadata of the source Observable, to\n * be consumed as `next` emissions. Use it in conjunction with\n * {@link dematerialize}.\n *\n * ## Example\n * Convert a faulty Observable to an Observable of Notifications\n * ```javascript\n * const letters = of('a', 'b', 13, 'd');\n * const upperCase = letters.pipe(map(x => x.toUpperCase()));\n * const materialized = upperCase.pipe(materialize());\n * materialized.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n * //   [as project] (http://1, hasValue: false}\n * ```\n *\n * @see {@link Notification}\n * @see {@link dematerialize}\n *\n * @return {Observable<Notification<T>>} An Observable that emits\n * {@link Notification} objects that wrap the original emissions from the source\n * Observable with metadata.\n * @method materialize\n * @owner Observable\n */\nexport function materialize<T>(): OperatorFunction<T, Notification<T>> {\n  return function materializeOperatorFunction(source: Observable<T>) {\n    return source.lift(new MaterializeOperator());\n  };\n}\n\nclass MaterializeOperator<T> implements Operator<T, Notification<T>> {\n  call(subscriber: Subscriber<Notification<T>>, source: any): any {\n    return source.subscribe(new MaterializeSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MaterializeSubscriber<T> extends Subscriber<T> {\n  constructor(destination: Subscriber<Notification<T>>) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    this.destination.next(Notification.createNext(value));\n  }\n\n  protected _error(err: any) {\n    const destination = this.destination;\n    destination.next(Notification.createError(err));\n    destination.complete();\n  }\n\n  protected _complete() {\n    const destination = this.destination;\n    destination.next(Notification.createComplete());\n    destination.complete();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function scan<T>(accumulator: (acc: T, value: T, index: number) => T, seed?: T): MonoTypeOperatorFunction<T>;\nexport function scan<T>(accumulator: (acc: T[], value: T, index: number) => T[], seed?: T[]): OperatorFunction<T, T[]>;\nexport function scan<T, R>(accumulator: (acc: R, value: T, index: number) => R, seed?: R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Applies an accumulator function over the source Observable, and returns each\n * intermediate result, with an optional seed value.\n *\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\n * accumulation whenever the source emits a value.</span>\n *\n * <img src=\"./img/scan.png\" width=\"100%\">\n *\n * Combines together all values emitted on the source, using an accumulator\n * function that knows how to join a new source value into the accumulation from\n * the past. Is similar to {@link reduce}, but emits the intermediate\n * accumulations.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * ## Example\n * Count the number of click events\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const ones = clicks.pipe(mapTo(1));\n * const seed = 0;\n * const count = ones.pipe(scan((acc, one) => acc + one, seed));\n * count.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link reduce}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator\n * The accumulator function called on each source value.\n * @param {T|R} [seed] The initial accumulation value.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method scan\n * @owner Observable\n */\nexport function scan<T, R>(accumulator: (acc: R, value: T, index: number) => R, seed?: T | R): OperatorFunction<T, R> {\n  let hasSeed = false;\n  // providing a seed of `undefined` *should* be valid and trigger\n  // hasSeed! so don't use `seed !== undefined` checks!\n  // For this reason, we have to check it here at the original call site\n  // otherwise inside Operator/Subscriber we won't know if `undefined`\n  // means they didn't provide anything or if they literally provided `undefined`\n  if (arguments.length >= 2) {\n    hasSeed = true;\n  }\n\n  return function scanOperatorFunction(source: Observable<T>): Observable<R> {\n    return source.lift(new ScanOperator(accumulator, seed, hasSeed));\n  };\n}\n\nclass ScanOperator<T, R> implements Operator<T, R> {\n  constructor(private accumulator: (acc: R, value: T, index: number) => R, private seed?: T | R, private hasSeed: boolean = false) {}\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ScanSubscriber<T, R> extends Subscriber<T> {\n  private index: number = 0;\n\n  get seed(): T | R {\n    return this._seed;\n  }\n\n  set seed(value: T | R) {\n    this.hasSeed = true;\n    this._seed = value;\n  }\n\n  constructor(destination: Subscriber<R>, private accumulator: (acc: R, value: T, index: number) => R, private _seed: T | R,\n              private hasSeed: boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (!this.hasSeed) {\n      this.seed = value;\n      this.destination.next(value);\n    } else {\n      return this._tryNext(value);\n    }\n  }\n\n  private _tryNext(value: T): void {\n    const index = this.index++;\n    let result: any;\n    try {\n      result = this.accumulator(<R>this.seed, value, index);\n    } catch (err) {\n      this.destination.error(err);\n    }\n    this.seed = result;\n    this.destination.next(result);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { ObservableInput, OperatorFunction } from '../types';\n\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * ## Example\n * Count the number of click events\n * ```javascript\n * const click$ = fromEvent(document, 'click');\n * const one$ = click$.pipe(mapTo(1));\n * const seed = 0;\n * const count$ = one$.pipe(\n *   mergeScan((acc, one) => of(acc + one), seed),\n * );\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * 1\n * 2\n * 3\n * 4\n * // ...and so on for each click\n * ```\n *\n * @param {function(acc: R, value: T): Observable<R>} accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n * input Observables being subscribed to concurrently.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method mergeScan\n * @owner Observable\n */\nexport function mergeScan<T, R>(accumulator: (acc: R, value: T) => ObservableInput<R>,\n                                seed: R,\n                                concurrent: number = Number.POSITIVE_INFINITY): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift(new MergeScanOperator(accumulator, seed, concurrent));\n}\n\nexport class MergeScanOperator<T, R> implements Operator<T, R> {\n  constructor(private accumulator: (acc: R, value: T) => ObservableInput<R>,\n              private seed: R,\n              private concurrent: number) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MergeScanSubscriber(\n      subscriber, this.accumulator, this.seed, this.concurrent\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class MergeScanSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private hasValue: boolean = false;\n  private hasCompleted: boolean = false;\n  private buffer: Observable<any>[] = [];\n  private active: number = 0;\n  protected index: number = 0;\n\n  constructor(destination: Subscriber<R>,\n              private accumulator: (acc: R, value: T) => ObservableInput<R>,\n              private acc: R,\n              private concurrent: number) {\n    super(destination);\n  }\n\n  protected _next(value: any): void {\n    if (this.active < this.concurrent) {\n      const index = this.index++;\n      const ish = tryCatch(this.accumulator)(this.acc, value);\n      const destination = this.destination;\n      if (ish === errorObject) {\n        destination.error(errorObject.e);\n      } else {\n        this.active++;\n        this._innerSub(ish, value, index);\n      }\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  private _innerSub(ish: any, value: T, index: number): void {\n    this.add(subscribeToResult<T, R>(this, ish, value, index));\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (this.active === 0 && this.buffer.length === 0) {\n      if (this.hasValue === false) {\n        this.destination.next(this.acc);\n      }\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    const { destination } = this;\n    this.acc = innerValue;\n    this.hasValue = true;\n    destination.next(innerValue);\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    const buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      if (this.hasValue === false) {\n        this.destination.next(this.acc);\n      }\n      this.destination.complete();\n    }\n  }\n}\n","import { Subject, SubjectSubscriber } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { TeardownLogic } from '../types';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\n\n/**\n * @class ConnectableObservable<T>\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n\n  protected _subject: Subject<T>;\n  protected _refCount: number = 0;\n  protected _connection: Subscription;\n  /** @internal */\n  _isComplete = false;\n\n  constructor(public source: Observable<T>,\n              protected subjectFactory: () => Subject<T>) {\n    super();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  protected getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject;\n  }\n\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription();\n      connection.add(this.source\n        .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      } else {\n        this._connection = connection;\n      }\n    }\n    return connection;\n  }\n\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n\nconst connectableProto = <any>ConnectableObservable.prototype;\n\nexport const connectableObservableDescriptor: PropertyDescriptorMap = {\n  operator: { value: null },\n  _refCount: { value: 0, writable: true },\n  _subject: { value: null, writable: true },\n  _connection: { value: null, writable: true },\n  _subscribe: { value: connectableProto._subscribe },\n  _isComplete: { value: connectableProto._isComplete, writable: true },\n  getSubject: { value: connectableProto.getSubject },\n  connect: { value: connectableProto.connect },\n  refCount: { value: connectableProto.refCount }\n};\n\nclass ConnectableSubscriber<T> extends SubjectSubscriber<T> {\n  constructor(destination: Subject<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n  protected _error(err: any): void {\n    this._unsubscribe();\n    super._error(err);\n  }\n  protected _complete(): void {\n    this.connectable._isComplete = true;\n    this._unsubscribe();\n    super._complete();\n  }\n  protected _unsubscribe() {\n    const connectable = <any>this.connectable;\n    if (connectable) {\n      this.connectable = null;\n      const connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  }\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  protected _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // Observable.range(0, 10)\n    //   .publish()\n    //   .refCount()\n    //   .take(5)\n    //   .subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nimport { MonoTypeOperatorFunction, PartialObserver, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n *\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * ## Example\n * Ensure values in subscribe are called just before browser repaint.\n * ```javascript\n * const intervals = interval(10);                // Intervals are scheduled\n *                                                // with async scheduler by default...\n * intervals.pipe(\n *   observeOn(animationFrameScheduler),          // ...but we will observe on animationFrame\n * )                                              // scheduler to ensure smooth animation.\n * .subscribe(val => {\n *   someDiv.style.height = val + 'px';\n * });\n * ```\n *\n * @see {@link delay}\n *\n * @param {SchedulerLike} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n * but with provided scheduler.\n *\n * @method observeOn\n * @owner Observable\n */\nexport function observeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> {\n  return function observeOnOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new ObserveOnOperator(scheduler, delay));\n  };\n}\n\nexport class ObserveOnOperator<T> implements Operator<T, T> {\n  constructor(private scheduler: SchedulerLike, private delay: number = 0) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class ObserveOnSubscriber<T> extends Subscriber<T> {\n  /** @nocollapse */\n  static dispatch(this: SchedulerAction<ObserveOnMessage>, arg: ObserveOnMessage) {\n    const { notification, destination } = arg;\n    notification.observe(destination);\n    this.unsubscribe();\n  }\n\n  constructor(destination: Subscriber<T>,\n              private scheduler: SchedulerLike,\n              private delay: number = 0) {\n    super(destination);\n  }\n\n  private scheduleMessage(notification: Notification<any>): void {\n    this.add(this.scheduler.schedule(\n      ObserveOnSubscriber.dispatch,\n      this.delay,\n      new ObserveOnMessage(notification, this.destination)\n    ));\n  }\n\n  protected _next(value: T): void {\n    this.scheduleMessage(Notification.createNext(value));\n  }\n\n  protected _error(err: any): void {\n    this.scheduleMessage(Notification.createError(err));\n  }\n\n  protected _complete(): void {\n    this.scheduleMessage(Notification.createComplete());\n  }\n}\n\nexport class ObserveOnMessage {\n  constructor(public notification: Notification<any>,\n              public destination: PartialObserver<any>) {\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { QueueScheduler } from './QueueScheduler';\nimport { SchedulerAction } from '../types';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class QueueAction<T> extends AsyncAction<T> {\n\n  constructor(protected scheduler: QueueScheduler,\n              protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (delay > 0) {\n      return super.schedule(state, delay);\n    }\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  }\n\n  public execute(state: T, delay: number): any {\n    return (delay > 0 || this.closed) ?\n      super.execute(state, delay) :\n      this._execute(state, delay) ;\n  }\n\n  protected requestAsyncId(scheduler: QueueScheduler, id?: any, delay: number = 0): any {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Otherwise flush the scheduler starting with this action.\n    return scheduler.flush(this);\n  }\n}\n","import { Observable } from '../Observable';\nimport { from } from '../observable/from';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { isArray } from '../util/isArray';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { ObservableInput, OperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function onErrorResumeNext<T, R>(v: ObservableInput<R>): OperatorFunction<T, R>;\nexport function onErrorResumeNext<T, T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): OperatorFunction<T, R>;\nexport function onErrorResumeNext<T, T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): OperatorFunction<T, R>;\nexport function onErrorResumeNext<T, T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): OperatorFunction<T, R>;\nexport function onErrorResumeNext<T, T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): OperatorFunction<T, R> ;\nexport function onErrorResumeNext<T, R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, R>;\nexport function onErrorResumeNext<T, R>(array: ObservableInput<any>[]): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * <img src=\"./img/onErrorResumeNext.png\" width=\"100%\">\n *\n * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n * as the source.\n *\n * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n * be happening until there is no more Observables left in the series, at which point returned Observable will\n * complete - even if the last subscribed stream ended with an error.\n *\n * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n * an error.\n *\n * Note that you do not get any access to errors emitted by the Observables. In particular do not\n * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take\n * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.\n *\n *\n * ## Example\n * Subscribe to the next Observable after map fails\n * ```javascript\n * of(1, 2, 3, 0).pipe(\n *   map(x => {\n *       if (x === 0) { throw Error(); }\n         return 10 / x;\n *   }),\n *   onErrorResumeNext(of(1, 2, 3)),\n * )\n * .subscribe(\n *   val => console.log(val),\n *   err => console.log(err),          // Will never be called.\n *   () => console.log('that\\'s it!')\n * );\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // \"that's it!\"\n * ```\n *\n * @see {@link concat}\n * @see {@link catch}\n *\n * @param {...ObservableInput} observables Observables passed either directly or as an array.\n * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes\n * to the next passed Observable and so on, until it completes or runs out of Observables.\n * @method onErrorResumeNext\n * @owner Observable\n */\n\nexport function onErrorResumeNext<T, R>(...nextSources: Array<ObservableInput<any> |\n                                                       Array<ObservableInput<any>> |\n                                                       ((...values: Array<any>) => R)>): OperatorFunction<T, R> {\n  if (nextSources.length === 1 && isArray(nextSources[0])) {\n    nextSources = <Array<Observable<any>>>nextSources[0];\n  }\n\n  return (source: Observable<T>) => source.lift(new OnErrorResumeNextOperator<T, R>(nextSources));\n}\n\n/* tslint:disable:max-line-length */\nexport function onErrorResumeNextStatic<R>(v: ObservableInput<R>): Observable<R>;\nexport function onErrorResumeNextStatic<T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<R>;\nexport function onErrorResumeNextStatic<T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<R>;\nexport function onErrorResumeNextStatic<T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<R>;\nexport function onErrorResumeNextStatic<T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<R>;\n\nexport function onErrorResumeNextStatic<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\nexport function onErrorResumeNextStatic<R>(array: ObservableInput<any>[]): Observable<R>;\n/* tslint:enable:max-line-length */\n\nexport function onErrorResumeNextStatic<T, R>(...nextSources: Array<ObservableInput<any> |\n                                                              Array<ObservableInput<any>> |\n                                                              ((...values: Array<any>) => R)>): Observable<R> {\n  let source: ObservableInput<any> = null;\n\n  if (nextSources.length === 1 && isArray(nextSources[0])) {\n    nextSources = <Array<ObservableInput<any>>>nextSources[0];\n  }\n  source = nextSources.shift();\n\n  return from(source, null).lift(new OnErrorResumeNextOperator<T, R>(nextSources));\n}\n\nclass OnErrorResumeNextOperator<T, R> implements Operator<T, R> {\n  constructor(private nextSources: Array<ObservableInput<any>>) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));\n  }\n}\n\nclass OnErrorResumeNextSubscriber<T, R> extends OuterSubscriber<T, R> {\n  constructor(protected destination: Subscriber<T>,\n              private nextSources: Array<ObservableInput<any>>) {\n    super(destination);\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, any>): void {\n    this.subscribeToNextSource();\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, any>): void {\n    this.subscribeToNextSource();\n  }\n\n  protected _error(err: any): void {\n    this.subscribeToNextSource();\n  }\n\n  protected _complete(): void {\n    this.subscribeToNextSource();\n  }\n\n  private subscribeToNextSource(): void {\n    const next = this.nextSources.shift();\n    if (next) {\n      this.add(subscribeToResult(this, next));\n    } else {\n      this.destination.complete();\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\n\n/**\n * Groups pairs of consecutive emissions together and emits them as an array of\n * two values.\n *\n * <span class=\"informal\">Puts the current value and previous value together as\n * an array, and emits that.</span>\n *\n * <img src=\"./img/pairwise.png\" width=\"100%\">\n *\n * The Nth emission from the source Observable will cause the output Observable\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n * pair. For this reason, `pairwise` emits on the second and subsequent\n * emissions from the source Observable, but not on the first emission, because\n * there is no previous value in that case.\n *\n * ## Example\n * On every click (starting from the second), emit the relative distance to the previous click\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const pairs = clicks.pipe(pairwise());\n * const distance = pairs.pipe(\n *   map(pair => {\n *     const x0 = pair[0].clientX;\n *     const y0 = pair[0].clientY;\n *     const x1 = pair[1].clientX;\n *     const y1 = pair[1].clientY;\n *     return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n *   }),\n * );\n * distance.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n *\n * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of\n * consecutive values from the source Observable.\n * @method pairwise\n * @owner Observable\n */\nexport function pairwise<T>(): OperatorFunction<T, [T, T]> {\n  return (source: Observable<T>) => source.lift(new PairwiseOperator());\n}\n\nclass PairwiseOperator<T> implements Operator<T, [T, T]> {\n  call(subscriber: Subscriber<[T, T]>, source: any): any {\n    return source.subscribe(new PairwiseSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass PairwiseSubscriber<T> extends Subscriber<T> {\n  private prev: T;\n  private hasPrev: boolean = false;\n\n  constructor(destination: Subscriber<[T, T]>) {\n    super(destination);\n  }\n\n  _next(value: T): void {\n    if (this.hasPrev) {\n      this.destination.next([this.prev, value]);\n    } else {\n      this.hasPrev = true;\n    }\n\n    this.prev = value;\n  }\n}\n","import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { SubscriptionLike } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\n\n/**\n * @class BehaviorSubject<T>\n */\nexport class BehaviorSubject<T> extends Subject<T> {\n\n  constructor(private _value: T) {\n    super();\n  }\n\n  get value(): T {\n    return this.getValue();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    const subscription = super._subscribe(subscriber);\n    if (subscription && !(<SubscriptionLike>subscription).closed) {\n      subscriber.next(this._value);\n    }\n    return subscription;\n  }\n\n  getValue(): T {\n    if (this.hasError) {\n      throw this.thrownError;\n    } else if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else {\n      return this._value;\n    }\n  }\n\n  next(value: T): void {\n    super.next(this._value = value);\n  }\n}\n","import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\n\n/**\n * @class AsyncSubject<T>\n */\nexport class AsyncSubject<T> extends Subject<T> {\n  private value: T = null;\n  private hasNext: boolean = false;\n  private hasCompleted: boolean = false;\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<any>): Subscription {\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n      return Subscription.EMPTY;\n    } else if (this.hasCompleted && this.hasNext) {\n      subscriber.next(this.value);\n      subscriber.complete();\n      return Subscription.EMPTY;\n    }\n    return super._subscribe(subscriber);\n  }\n\n  next(value: T): void {\n    if (!this.hasCompleted) {\n      this.value = value;\n      this.hasNext = true;\n    }\n  }\n\n  error(error: any): void {\n    if (!this.hasCompleted) {\n      super.error(error);\n    }\n  }\n\n  complete(): void {\n    this.hasCompleted = true;\n    if (this.hasNext) {\n      super.next(this.value);\n    }\n    super.complete();\n  }\n}\n","import { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\n\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * ## Examples\n * Schedule recursively first, then do something\n * ```javascript\n * Rx.Scheduler.queue.schedule(() => {\n *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n * ```\n *\n * Reschedule itself recursively\n * ```javascript\n * Rx.Scheduler.queue.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n * ```\n *\n * @static true\n * @name queue\n * @owner Scheduler\n */\n\nexport const queue = new QueueScheduler(QueueAction);\n","import { AsyncScheduler } from './AsyncScheduler';\n\nexport class QueueScheduler extends AsyncScheduler {\n}\n","import { Subject } from './Subject';\nimport { SchedulerLike } from './types';\nimport { queue } from './scheduler/queue';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\n/**\n * @class ReplaySubject<T>\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _events: (ReplayEvent<T> | T)[] = [];\n  private _bufferSize: number;\n  private _windowTime: number;\n  private _infiniteTimeWindow: boolean = false;\n\n  constructor(bufferSize: number = Number.POSITIVE_INFINITY,\n              windowTime: number = Number.POSITIVE_INFINITY,\n              private scheduler?: SchedulerLike) {\n    super();\n    this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    this._windowTime = windowTime < 1 ? 1 : windowTime;\n\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      this._infiniteTimeWindow = true;\n      this.next = this.nextInfiniteTimeWindow;\n    } else {\n      this.next = this.nextTimeWindow;\n    }\n  }\n\n  private nextInfiniteTimeWindow(value: T): void {\n    const _events = this._events;\n    _events.push(value);\n    // Since this method is invoked in every next() call than the buffer\n    // can overgrow the max size only by one item\n    if (_events.length > this._bufferSize) {\n      _events.shift();\n    }\n\n    super.next(value);\n  }\n\n  private nextTimeWindow(value: T): void {\n    this._events.push(new ReplayEvent(this._getNow(), value));\n    this._trimBufferThenGetEvents();\n\n    super.next(value);\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    // When `_infiniteTimeWindow === true` then the buffer is already trimmed\n    const _infiniteTimeWindow = this._infiniteTimeWindow;\n    const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n    const scheduler = this.scheduler;\n    const len = _events.length;\n    let subscription: Subscription;\n\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.isStopped || this.hasError) {\n      subscription = Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      subscription = new SubjectSubscription(this, subscriber);\n    }\n\n    if (scheduler) {\n      subscriber.add(subscriber = new ObserveOnSubscriber<T>(subscriber, scheduler));\n    }\n\n    if (_infiniteTimeWindow) {\n      for (let i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(<T>_events[i]);\n      }\n    } else {\n      for (let i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next((<ReplayEvent<T>>_events[i]).value);\n      }\n    }\n\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n    } else if (this.isStopped) {\n      subscriber.complete();\n    }\n\n    return subscription;\n  }\n\n  _getNow(): number {\n    return (this.scheduler || queue).now();\n  }\n\n  private _trimBufferThenGetEvents(): ReplayEvent<T>[] {\n    const now = this._getNow();\n    const _bufferSize = this._bufferSize;\n    const _windowTime = this._windowTime;\n    const _events = <ReplayEvent<T>[]>this._events;\n\n    const eventsCount = _events.length;\n    let spliceCount = 0;\n\n    // Trim events that fall out of the time window.\n    // Start at the front of the list. Break early once\n    // we encounter an event that falls within the window.\n    while (spliceCount < eventsCount) {\n      if ((now - _events[spliceCount].time) < _windowTime) {\n        break;\n      }\n      spliceCount++;\n    }\n\n    if (eventsCount > _bufferSize) {\n      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n    }\n\n    if (spliceCount > 0) {\n      _events.splice(0, spliceCount);\n    }\n\n    return _events;\n  }\n\n}\n\nclass ReplayEvent<T> {\n  constructor(public time: number, public value: T) {\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\n\nimport { Observer, OperatorFunction } from '../types';\n\n/**\n * Compares all values of two observables in sequence using an optional comparor function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * <img src=\"./img/sequenceEqual.png\" width=\"100%\">\n *\n * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other complets, the returned observable will never complete.\n *\n * ## Example\n * figure out if the Konami code matches\n * ```javascript\n * const codes = from([\n *   'ArrowUp',\n *   'ArrowUp',\n *   'ArrowDown',\n *   'ArrowDown',\n *   'ArrowLeft',\n *   'ArrowRight',\n *   'ArrowLeft',\n *   'ArrowRight',\n *   'KeyB',\n *   'KeyA',\n *   'Enter', // no start key, clearly.\n * ]);\n *\n * const keys = fromEvent(document, 'keyup').pipe(map(e => e.code));\n * const matches = keys.pipe(\n *   bufferCount(11, 1),\n *   mergeMap(\n *     last11 => from(last11).pipe(sequenceEqual(codes)),\n *   ),\n * );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n * @param {function} [comparor] An optional function to compare each value pair\n * @return {Observable} An Observable of a single boolean value representing whether or not\n * the values emitted by both observables were equal in sequence.\n * @method sequenceEqual\n * @owner Observable\n */\nexport function sequenceEqual<T>(compareTo: Observable<T>,\n                                 comparor?: (a: T, b: T) => boolean): OperatorFunction<T, boolean> {\n  return (source: Observable<T>) => source.lift(new SequenceEqualOperator(compareTo, comparor));\n}\n\nexport class SequenceEqualOperator<T> implements Operator<T, boolean> {\n  constructor(private compareTo: Observable<T>,\n              private comparor: (a: T, b: T) => boolean) {\n  }\n\n  call(subscriber: Subscriber<boolean>, source: any): any {\n    return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class SequenceEqualSubscriber<T, R> extends Subscriber<T> {\n  private _a: T[] = [];\n  private _b: T[] = [];\n  private _oneComplete = false;\n\n  constructor(destination: Observer<R>,\n              private compareTo: Observable<T>,\n              private comparor: (a: T, b: T) => boolean) {\n    super(destination);\n    this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));\n  }\n\n  protected _next(value: T): void {\n    if (this._oneComplete && this._b.length === 0) {\n      this.emit(false);\n    } else {\n      this._a.push(value);\n      this.checkValues();\n    }\n  }\n\n  public _complete(): void {\n    if (this._oneComplete) {\n      this.emit(this._a.length === 0 && this._b.length === 0);\n    } else {\n      this._oneComplete = true;\n    }\n  }\n\n  checkValues() {\n    const { _a, _b, comparor } = this;\n    while (_a.length > 0 && _b.length > 0) {\n      let a = _a.shift();\n      let b = _b.shift();\n      let areEqual = false;\n      if (comparor) {\n        areEqual = tryCatch(comparor)(a, b);\n        if (areEqual === errorObject) {\n          this.destination.error(errorObject.e);\n        }\n      } else {\n        areEqual = a === b;\n      }\n      if (!areEqual) {\n        this.emit(false);\n      }\n    }\n  }\n\n  emit(value: boolean) {\n    const { destination } = this;\n    destination.next(value);\n    destination.complete();\n  }\n\n  nextB(value: T) {\n    if (this._oneComplete && this._a.length === 0) {\n      this.emit(false);\n    } else {\n      this._b.push(value);\n      this.checkValues();\n    }\n  }\n}\n\nclass SequenceEqualCompareToSubscriber<T, R> extends Subscriber<T> {\n  constructor(destination: Observer<R>, private parent: SequenceEqualSubscriber<T, R>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    this.parent.nextB(value);\n  }\n\n  protected _error(err: any): void {\n    this.parent.error(err);\n  }\n\n  protected _complete(): void {\n    this.parent._complete();\n  }\n}\n","import { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { fromArray } from './fromArray';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { TeardownLogic } from '../types';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n\n/**\n * Returns an Observable that mirrors the first source Observable to emit an item.\n *\n * ## Example\n * ### Subscribes to the observable that was the first to start emitting.\n *\n * ```javascript\n * const obs1 = interval(1000).pipe(mapTo('fast one'));\n * const obs2 = interval(3000).pipe(mapTo('medium one'));\n * const obs3 = interval(5000).pipe(mapTo('slow one'));\n *\n * race(obs3, obs1, obs2)\n * .subscribe(\n *   winner => console.log(winner)\n * );\n *\n * // result:\n * // a series of 'fast one'\n * ```\n *\n * @param {...Observables} ...observables sources used to race for which Observable emits first.\n * @return {Observable} an Observable that mirrors the output of the first Observable to emit an item.\n * @static true\n * @name race\n * @owner Observable\n */\nexport function race<T>(observables: Array<Observable<T>>): Observable<T>;\nexport function race<T>(observables: Array<Observable<any>>): Observable<T>;\nexport function race<T>(...observables: Array<Observable<T> | Array<Observable<T>>>): Observable<T>;\nexport function race<T>(...observables: Array<Observable<any> | Array<Observable<any>>>): Observable<T> {\n  // if the only argument is an array, it was most likely called with\n  // `race([obs1, obs2, ...])`\n  if (observables.length === 1) {\n    if (isArray(observables[0])) {\n      observables = <Array<Observable<any>>>observables[0];\n    } else {\n      return <Observable<any>>observables[0];\n    }\n  }\n\n  return fromArray(observables, undefined).lift(new RaceOperator<T>());\n}\n\nexport class RaceOperator<T> implements Operator<T, T> {\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new RaceSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class RaceSubscriber<T> extends OuterSubscriber<T, T> {\n  private hasFirst: boolean = false;\n  private observables: Observable<any>[] = [];\n  private subscriptions: Subscription[] = [];\n\n  constructor(destination: Subscriber<T>) {\n    super(destination);\n  }\n\n  protected _next(observable: any): void {\n    this.observables.push(observable);\n  }\n\n  protected _complete() {\n    const observables = this.observables;\n    const len = observables.length;\n\n    if (len === 0) {\n      this.destination.complete();\n    } else {\n      for (let i = 0; i < len && !this.hasFirst; i++) {\n        let observable = observables[i];\n        let subscription = subscribeToResult(this, observable, observable as any, i);\n\n        if (this.subscriptions) {\n          this.subscriptions.push(subscription);\n        }\n        this.add(subscription);\n      }\n      this.observables = null;\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: T,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, T>): void {\n    if (!this.hasFirst) {\n      this.hasFirst = true;\n\n      for (let i = 0; i < this.subscriptions.length; i++) {\n        if (i !== outerIndex) {\n          let subscription = this.subscriptions[i];\n\n          subscription.unsubscribe();\n          this.remove(subscription);\n        }\n      }\n\n      this.subscriptions = null;\n    }\n\n    this.destination.next(innerValue);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { empty } from '../observable/empty';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.\n *\n * <img src=\"./img/repeat.png\" width=\"100%\">\n *\n * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most\n * count times.\n * @method repeat\n * @owner Observable\n */\nexport function repeat<T>(count: number = -1): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => {\n    if (count === 0) {\n      return empty();\n    } else if (count < 0) {\n      return source.lift(new RepeatOperator(-1, source));\n    } else {\n      return source.lift(new RepeatOperator(count - 1, source));\n    }\n  };\n}\n\nclass RepeatOperator<T> implements Operator<T, T> {\n  constructor(private count: number,\n              private source: Observable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass RepeatSubscriber<T> extends Subscriber<T> {\n  constructor(destination: Subscriber<any>,\n              private count: number,\n              private source: Observable<T>) {\n    super(destination);\n  }\n  complete() {\n    if (!this.isStopped) {\n      const { source, count } = this;\n      if (count === 0) {\n        return super.complete();\n      } else if (count > -1) {\n        this.count = count - 1;\n      }\n      source.subscribe(this._unsubscribeAndRecycle());\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\n\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n * this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/repeatWhen.png\" width=\"100%\">\n *\n * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with\n * which a user can `complete` or `error`, aborting the repetition.\n * @return {Observable} The source Observable modified with repeat logic.\n * @method repeatWhen\n * @owner Observable\n */\nexport function repeatWhen<T>(notifier: (notifications: Observable<any>) => Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new RepeatWhenOperator(notifier));\n}\n\nclass RepeatWhenOperator<T> implements Operator<T, T> {\n  constructor(protected notifier: (notifications: Observable<any>) => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass RepeatWhenSubscriber<T, R> extends OuterSubscriber<T, R> {\n\n  private notifications: Subject<any>;\n  private retries: Observable<any>;\n  private retriesSubscription: Subscription;\n  private sourceIsBeingSubscribedTo: boolean = true;\n\n  constructor(destination: Subscriber<R>,\n              private notifier: (notifications: Observable<any>) => Observable<any>,\n              private source: Observable<T>) {\n    super(destination);\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.sourceIsBeingSubscribedTo = true;\n    this.source.subscribe(this);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, R>): void {\n    if (this.sourceIsBeingSubscribedTo === false) {\n      return super.complete();\n    }\n  }\n\n  complete() {\n    this.sourceIsBeingSubscribedTo = false;\n\n    if (!this.isStopped) {\n      if (!this.retries) {\n        this.subscribeToRetries();\n      }\n      if (!this.retriesSubscription || this.retriesSubscription.closed) {\n        return super.complete();\n      }\n\n      this._unsubscribeAndRecycle();\n      this.notifications.next();\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    const { notifications, retriesSubscription } = this;\n    if (notifications) {\n      notifications.unsubscribe();\n      this.notifications = null;\n    }\n    if (retriesSubscription) {\n      retriesSubscription.unsubscribe();\n      this.retriesSubscription = null;\n    }\n    this.retries = null;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribeAndRecycle(): Subscriber<T> {\n    const { _unsubscribe } = this;\n\n    this._unsubscribe = null;\n    super._unsubscribeAndRecycle();\n    this._unsubscribe = _unsubscribe;\n\n    return this;\n  }\n\n  private subscribeToRetries() {\n    this.notifications = new Subject();\n    const retries = tryCatch(this.notifier)(this.notifications);\n    if (retries === errorObject) {\n      return super.complete();\n    }\n    this.retries = retries;\n    this.retriesSubscription = subscribeToResult(this, retries);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\n\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n * as a number parameter) rather than propagating the `error` call.\n *\n * <img src=\"./img/retry.png\" width=\"100%\">\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n * @param {number} count - Number of retry attempts before failing.\n * @return {Observable} The source Observable modified with the retry logic.\n * @method retry\n * @owner Observable\n */\nexport function retry<T>(count: number = -1): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new RetryOperator(count, source));\n}\n\nclass RetryOperator<T> implements Operator<T, T> {\n  constructor(private count: number,\n              private source: Observable<T>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass RetrySubscriber<T> extends Subscriber<T> {\n  constructor(destination: Subscriber<any>,\n              private count: number,\n              private source: Observable<T>) {\n    super(destination);\n  }\n  error(err: any) {\n    if (!this.isStopped) {\n      const { source, count } = this;\n      if (count === 0) {\n        return super.error(err);\n      } else if (count > -1) {\n        this.count = count - 1;\n      }\n      source.subscribe(this._unsubscribeAndRecycle());\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\n\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n * subscription. Otherwise this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/retryWhen.png\" width=\"100%\">\n *\n * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a\n * user can `complete` or `error`, aborting the retry.\n * @return {Observable} The source Observable modified with retry logic.\n * @method retryWhen\n * @owner Observable\n */\nexport function retryWhen<T>(notifier: (errors: Observable<any>) => Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new RetryWhenOperator(notifier, source));\n}\n\nclass RetryWhenOperator<T> implements Operator<T, T> {\n  constructor(protected notifier: (errors: Observable<any>) => Observable<any>,\n              protected source: Observable<T>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass RetryWhenSubscriber<T, R> extends OuterSubscriber<T, R> {\n\n  private errors: Subject<any>;\n  private retries: Observable<any>;\n  private retriesSubscription: Subscription;\n\n  constructor(destination: Subscriber<R>,\n              private notifier: (errors: Observable<any>) => Observable<any>,\n              private source: Observable<T>) {\n    super(destination);\n  }\n\n  error(err: any) {\n    if (!this.isStopped) {\n\n      let errors = this.errors;\n      let retries: any = this.retries;\n      let retriesSubscription = this.retriesSubscription;\n\n      if (!retries) {\n        errors = new Subject();\n        retries = tryCatch(this.notifier)(errors);\n        if (retries === errorObject) {\n          return super.error(errorObject.e);\n        }\n        retriesSubscription = subscribeToResult(this, retries);\n      } else {\n        this.errors = null;\n        this.retriesSubscription = null;\n      }\n\n      this._unsubscribeAndRecycle();\n\n      this.errors = errors;\n      this.retries = retries;\n      this.retriesSubscription = retriesSubscription;\n\n      errors.next(err);\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    const { errors, retriesSubscription } = this;\n    if (errors) {\n      errors.unsubscribe();\n      this.errors = null;\n    }\n    if (retriesSubscription) {\n      retriesSubscription.unsubscribe();\n      this.retriesSubscription = null;\n    }\n    this.retries = null;\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    const { _unsubscribe } = this;\n\n    this._unsubscribe = null;\n    this._unsubscribeAndRecycle();\n    this._unsubscribe = _unsubscribe;\n\n    this.source.subscribe(this);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` Observable emits something.</span>\n *\n * <img src=\"./img/sample.png\" width=\"100%\">\n *\n * Whenever the `notifier` Observable emits a value or completes, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * ## Example\n * On every click, sample the most recent \"seconds\" timer\n * ```javascript\n * const seconds = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = seconds.pipe(sample(clicks));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {Observable<any>} notifier The Observable to use for sampling the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable whenever the notifier Observable\n * emits value or completes.\n * @method sample\n * @owner Observable\n */\nexport function sample<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SampleOperator(notifier));\n}\n\nclass SampleOperator<T> implements Operator<T, T> {\n  constructor(private notifier: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    const sampleSubscriber = new SampleSubscriber(subscriber);\n    const subscription = source.subscribe(sampleSubscriber);\n    subscription.add(subscribeToResult(sampleSubscriber, this.notifier));\n    return subscription;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SampleSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private value: T;\n  private hasValue: boolean = false;\n\n  protected _next(value: T) {\n    this.value = value;\n    this.hasValue = true;\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.emitValue();\n  }\n\n  notifyComplete(): void {\n    this.emitValue();\n  }\n\n  emitValue() {\n    if (this.hasValue) {\n      this.hasValue = false;\n      this.destination.next(this.value);\n    }\n  }\n}\n","let nextHandle = 1;\n\nconst tasksByHandle: { [handle: string]: () => void } = {};\n\nfunction runIfPresent(handle: number) {\n  const cb = tasksByHandle[handle];\n  if (cb) {\n    cb();\n  }\n}\n\nexport const Immediate = {\n  setImmediate(cb: () => void): number {\n    const handle = nextHandle++;\n    tasksByHandle[handle] = cb;\n    Promise.resolve().then(() => runIfPresent(handle));\n    return handle;\n  },\n\n  clearImmediate(handle: number): void {\n    delete tasksByHandle[handle];\n  },\n};\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { EmptyError } from '../util/EmptyError';\n\nimport { Observer, MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that emits the single item emitted by the source Observable that matches a specified\n * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no\n * items, notify of an IllegalArgumentException or NoSuchElementException respectively. If the source Observable\n * emits items but none match the specified predicate then `undefined` is emiited.\n *\n * <img src=\"./img/single.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches\n * the predicate or `undefined` when no items match.\n *\n * @method single\n * @owner Observable\n */\nexport function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SingleOperator(predicate, source));\n}\n\nclass SingleOperator<T> implements Operator<T, T> {\n  constructor(private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private source?: Observable<T>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SingleSubscriber<T> extends Subscriber<T> {\n  private seenValue: boolean = false;\n  private singleValue: T;\n  private index: number = 0;\n\n  constructor(destination: Observer<T>,\n              private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private source?: Observable<T>) {\n    super(destination);\n  }\n\n  private applySingleValue(value: T): void {\n    if (this.seenValue) {\n      this.destination.error('Sequence contains more than one element');\n    } else {\n      this.seenValue = true;\n      this.singleValue = value;\n    }\n  }\n\n  protected _next(value: T): void {\n    const index = this.index++;\n\n    if (this.predicate) {\n      this.tryNext(value, index);\n    } else {\n      this.applySingleValue(value);\n    }\n  }\n\n  private tryNext(value: T, index: number): void {\n    try {\n      if (this.predicate(value, index, this.source)) {\n        this.applySingleValue(value);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  }\n\n  protected _complete(): void {\n    const destination = this.destination;\n\n    if (this.index > 0) {\n      destination.next(this.seenValue ? this.singleValue : undefined);\n      destination.complete();\n    } else {\n      destination.error(new EmptyError);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * <img src=\"./img/skip.png\" width=\"100%\">\n *\n * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n * @return {Observable} An Observable that skips values emitted by the source Observable.\n *\n * @method skip\n * @owner Observable\n */\nexport function skip<T>(count: number): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SkipOperator(count));\n}\n\nclass SkipOperator<T> implements Operator<T, T> {\n  constructor(private total: number) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SkipSubscriber(subscriber, this.total));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SkipSubscriber<T> extends Subscriber<T> {\n  count: number = 0;\n\n  constructor(destination: Subscriber<T>, private total: number) {\n    super(destination);\n  }\n\n  protected _next(x: T) {\n    if (++this.count > this.total) {\n      this.destination.next(x);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Skip the last `count` values emitted by the source Observable.\n *\n * <img src=\"./img/skipLast.png\" width=\"100%\">\n *\n * `skipLast` returns an Observable that accumulates a queue with a length\n * enough to store the first `count` values. As more values are received,\n * values are taken from the front of the queue and produced on the result\n * sequence. This causes values to be delayed.\n *\n * ## Example\n * Skip the last 2 values of an Observable with many values\n * ```javascript\n * const many = range(1, 5);\n * const skipLastTwo = many.pipe(skipLast(2));\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n * ```\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n * ArgumentOutOrRangeError if `i < 0`.\n *\n * @param {number} count Number of elements to skip from the end of the source Observable.\n * @returns {Observable<T>} An Observable that skips the last count values\n * emitted by the source Observable.\n * @method skipLast\n * @owner Observable\n */\nexport function skipLast<T>(count: number): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SkipLastOperator(count));\n}\n\nclass SkipLastOperator<T> implements Operator<T, T> {\n  constructor(private _skipCount: number) {\n    if (this._skipCount < 0) {\n      throw new ArgumentOutOfRangeError;\n    }\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    if (this._skipCount === 0) {\n      // If we don't want to skip any values then just subscribe\n      // to Subscriber without any further logic.\n      return source.subscribe(new Subscriber(subscriber));\n    } else {\n      return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));\n    }\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SkipLastSubscriber<T> extends Subscriber<T> {\n  private _ring: T[];\n  private _count: number = 0;\n\n  constructor(destination: Subscriber<T>, private _skipCount: number) {\n    super(destination);\n    this._ring = new Array<T>(_skipCount);\n  }\n\n  protected _next(value: T): void {\n    const skipCount = this._skipCount;\n    const count = this._count++;\n\n    if (count < skipCount) {\n      this._ring[count] = value;\n    } else {\n      const currentIndex = count % skipCount;\n      const ring = this._ring;\n      const oldValue = ring[currentIndex];\n\n      ring[currentIndex] = value;\n      this.destination.next(oldValue);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { MonoTypeOperatorFunction, TeardownLogic, ObservableInput } from '../types';\nimport { Subscription } from '../Subscription';\n\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * <img src=\"./img/skipUntil.png\" width=\"100%\">\n *\n * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n * be mirrored by the resulting Observable.\n * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n * an item, then emits the remaining items.\n * @method skipUntil\n * @owner Observable\n */\nexport function skipUntil<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SkipUntilOperator(notifier));\n}\n\nclass SkipUntilOperator<T> implements Operator<T, T> {\n  constructor(private notifier: Observable<any>) {\n  }\n\n  call(destination: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SkipUntilSubscriber<T, R> extends OuterSubscriber<T, R> {\n\n  private hasValue: boolean = false;\n  private innerSubscription: Subscription;\n\n  constructor(destination: Subscriber<R>, notifier: ObservableInput<any>) {\n    super(destination);\n    this.add(this.innerSubscription = subscribeToResult(this, notifier));\n  }\n\n  protected _next(value: T) {\n    if (this.hasValue) {\n      super._next(value);\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.hasValue = true;\n    if (this.innerSubscription) {\n      this.innerSubscription.unsubscribe();\n    }\n  }\n\n  notifyComplete() {\n    /* do nothing */\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * <img src=\"./img/skipWhile.png\" width=\"100%\">\n *\n * @param {Function} predicate - A function to test each item emitted from the source Observable.\n * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the\n * specified predicate becomes false.\n * @method skipWhile\n * @owner Observable\n */\nexport function skipWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SkipWhileOperator(predicate));\n}\n\nclass SkipWhileOperator<T> implements Operator<T, T> {\n  constructor(private predicate: (value: T, index: number) => boolean) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SkipWhileSubscriber<T> extends Subscriber<T> {\n  private skipping: boolean = true;\n  private index: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number) => boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const destination = this.destination;\n    if (this.skipping) {\n      this.tryCallPredicate(value);\n    }\n\n    if (!this.skipping) {\n      destination.next(value);\n    }\n  }\n\n  private tryCallPredicate(value: T): void {\n    try {\n      const result = this.predicate(value, this.index++);\n      this.skipping = Boolean(result);\n    } catch (err) {\n      this.destination.error(err);\n    }\n  }\n}\n","import { Immediate } from '../util/Immediate';\nimport { AsyncAction } from './AsyncAction';\nimport { AsapScheduler } from './AsapScheduler';\nimport { SchedulerAction } from '../types';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AsapAction<T> extends AsyncAction<T> {\n\n  constructor(protected scheduler: AsapScheduler,\n              protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AsapScheduler, id?: any, delay: number = 0): any {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If a microtask has already been scheduled, don't schedule another\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n    // the current scheduled microtask id.\n    return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(\n      scheduler.flush.bind(scheduler, null)\n    ));\n  }\n  protected recycleAsyncId(scheduler: AsapScheduler, id?: any, delay: number = 0): any {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue is empty, cancel the requested microtask and\n    // set the scheduled flag to undefined so the next AsapAction will schedule\n    // its own.\n    if (scheduler.actions.length === 0) {\n      Immediate.clearImmediate(id);\n      scheduler.scheduled = undefined;\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n","import { AsapAction } from './AsapAction';\nimport { AsapScheduler } from './AsapScheduler';\n\n/**\n *\n * Asap Scheduler\n *\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n *\n * `asap` scheduler behaves the same as {@link async} scheduler when you use it to delay task\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n * code to end and then it will try to execute given task as fast as possible.\n *\n * `asap` scheduler will do its best to minimize time between end of currently executing code\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n * some (although minimal) unwanted delay.\n *\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\n * as soon as possible, `asap` scheduler is your best bet.\n *\n * ## Example\n * Compare async and asap scheduler<\n * ```javascript\n * Rx.Scheduler.async.schedule(() => console.log('async')); // scheduling 'async' first...\n * Rx.Scheduler.asap.schedule(() => console.log('asap'));\n *\n * // Logs:\n * // \"asap\"\n * // \"async\"\n * // ... but 'asap' goes first!\n * ```\n * @static true\n * @name asap\n * @owner Scheduler\n */\n\nexport const asap = new AsapScheduler(AsapAction);\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AsapScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n\n    this.active = true;\n    this.scheduled = undefined;\n\n    const {actions} = this;\n    let error: any;\n    let index: number = -1;\n    let count: number = actions.length;\n    action = action || actions.shift();\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (++index < count && (action = actions.shift()));\n\n    this.active = false;\n\n    if (error) {\n      while (++index < count && (action = actions.shift())) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { SchedulerLike, SchedulerAction } from '../types';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nimport { asap } from '../scheduler/asap';\nimport { isNumeric } from '../util/isNumeric';\n\nexport interface DispatchArg<T> {\n  source: Observable<T>;\n  subscriber: Subscriber<T>;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class SubscribeOnObservable<T> extends Observable<T> {\n  /** @nocollapse */\n  static create<T>(source: Observable<T>, delay: number = 0, scheduler: SchedulerLike = asap): Observable<T> {\n    return new SubscribeOnObservable(source, delay, scheduler);\n  }\n\n  /** @nocollapse */\n  static dispatch<T>(this: SchedulerAction<T>, arg: DispatchArg<T>): Subscription {\n    const { source, subscriber } = arg;\n    return this.add(source.subscribe(subscriber));\n  }\n\n  constructor(public source: Observable<T>,\n              private delayTime: number = 0,\n              private scheduler: SchedulerLike = asap) {\n    super();\n    if (!isNumeric(delayTime) || delayTime < 0) {\n      this.delayTime = 0;\n    }\n    if (!scheduler || typeof scheduler.schedule !== 'function') {\n      this.scheduler = asap;\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>) {\n    const delay = this.delayTime;\n    const source = this.source;\n    const scheduler = this.scheduler;\n\n    return scheduler.schedule<DispatchArg<any>>(SubscribeOnObservable.dispatch, delay, {\n      source, subscriber\n    });\n  }\n}\n","import { isArray } from './isArray';\n\nexport function isNumeric(val: any): val is number {\n  // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n  // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n  // subtraction forces infinities to NaN\n  // adding 1 corrects loss of precision from parseFloat (#15100)\n  return !isArray(val) && (val - parseFloat(val) + 1) >= 0;\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { map } from './map';\nimport { from } from '../observable/from';\n\n/* tslint:disable:max-line-length */\nexport function switchMap<T, R>(project: (value: T, index: number) => ObservableInput<R>): OperatorFunction<T, R>;\n/** @deprecated resultSelector is no longer supported, use inner map instead */\nexport function switchMap<T, R>(project: (value: T, index: number) => ObservableInput<R>, resultSelector: undefined): OperatorFunction<T, R>;\n/** @deprecated resultSelector is no longer supported, use inner map instead */\nexport function switchMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * ## Example\n * Rerun an interval Observable on every click event\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(switchMap((ev) => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nexport function switchMap<T, I, R>(\n  project: (value: T, index: number) => ObservableInput<I>,\n  resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R,\n): OperatorFunction<T, I|R> {\n  if (typeof resultSelector === 'function') {\n    return (source: Observable<T>) => source.pipe(\n      switchMap((a, i) => from(project(a, i)).pipe(\n        map((b, ii) => resultSelector(a, b, i, ii))\n      ))\n    );\n  }\n  return (source: Observable<T>) => source.lift(new SwitchMapOperator(project));\n}\n\nclass SwitchMapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => ObservableInput<R>) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SwitchMapSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private index: number = 0;\n  private innerSubscription: Subscription;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => ObservableInput<R>) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    let result: ObservableInput<R>;\n    const index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (error) {\n      this.destination.error(error);\n      return;\n    }\n    this._innerSub(result, value, index);\n  }\n\n  private _innerSub(result: ObservableInput<R>, value: T, index: number) {\n    const innerSubscription = this.innerSubscription;\n    if (innerSubscription) {\n      innerSubscription.unsubscribe();\n    }\n    this.add(this.innerSubscription = subscribeToResult(this, result, value, index));\n  }\n\n  protected _complete(): void {\n    const {innerSubscription} = this;\n    if (!innerSubscription || innerSubscription.closed) {\n      super._complete();\n    }\n  }\n\n  protected _unsubscribe() {\n    this.innerSubscription = null;\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    this.remove(innerSub);\n    this.innerSubscription = null;\n    if (this.isStopped) {\n      super._complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n      this.destination.next(innerValue);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Emits values emitted by the source Observable so long as each value satisfies\n * the given `predicate`, and then completes as soon as this `predicate` is not\n * satisfied.\n *\n * <span class=\"informal\">Takes values from the source only while they pass the\n * condition given. When the first value does not satisfy, it completes.</span>\n *\n * <img src=\"./img/takeWhile.png\" width=\"100%\">\n *\n * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n * emitted on the source is given to the `predicate` function which returns a\n * boolean, representing a condition to be satisfied by the source values. The\n * output Observable emits the source values until such time as the `predicate`\n * returns false, at which point `takeWhile` stops mirroring the source\n * Observable and completes the output Observable.\n *\n * ## Example\n * Emit click events only while the clientX property is greater than 200\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(takeWhile(ev => ev.clientX > 200));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates a value emitted by the source Observable and returns a boolean.\n * Also takes the (zero-based) index as the second argument.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable so long as each value satisfies the condition defined by the\n * `predicate`, then completes.\n * @method takeWhile\n * @owner Observable\n */\nexport function takeWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new TakeWhileOperator(predicate));\n}\n\nclass TakeWhileOperator<T> implements Operator<T, T> {\n  constructor(private predicate: (value: T, index: number) => boolean) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeWhileSubscriber<T> extends Subscriber<T> {\n  private index: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number) => boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const destination = this.destination;\n    let result: boolean;\n    try {\n      result = this.predicate(value, this.index++);\n    } catch (err) {\n      destination.error(err);\n      return;\n    }\n    this.nextOrComplete(value, result);\n  }\n\n  private nextOrComplete(value: T, predicateResult: boolean): void {\n    const destination = this.destination;\n    if (Boolean(predicateResult)) {\n      destination.next(value);\n    } else {\n      destination.complete();\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\n\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n\nimport { MonoTypeOperatorFunction, SubscribableOrPromise, TeardownLogic } from '../types';\n\nexport interface ThrottleConfig {\n  leading?: boolean;\n  trailing?: boolean;\n}\n\nexport const defaultThrottleConfig: ThrottleConfig = {\n  leading: true,\n  trailing: false\n};\n\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for a duration determined by another Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/throttle.png\" width=\"100%\">\n *\n * `throttle` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled by calling the `durationSelector` function with the source value,\n * which returns the \"duration\" Observable. When the duration Observable emits a\n * value or completes, the timer is disabled, and this process repeats for the\n * next source value.\n *\n * ## Example\n * Emit clicks at a rate of at most one click per second\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(throttle(ev => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration for each source value, returned as an Observable or a Promise.\n * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults\n * to `{ leading: true, trailing: false }`.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttle\n * @owner Observable\n */\nexport function throttle<T>(durationSelector: (value: T) => SubscribableOrPromise<any>,\n                            config: ThrottleConfig = defaultThrottleConfig): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing));\n}\n\nclass ThrottleOperator<T> implements Operator<T, T> {\n  constructor(private durationSelector: (value: T) => SubscribableOrPromise<any>,\n              private leading: boolean,\n              private trailing: boolean) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(\n      new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing)\n    );\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc\n * @ignore\n * @extends {Ignored}\n */\nclass ThrottleSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private _throttled: Subscription;\n  private _sendValue: T;\n  private _hasValue = false;\n\n  constructor(protected destination: Subscriber<T>,\n              private durationSelector: (value: T) => SubscribableOrPromise<number>,\n              private _leading: boolean,\n              private _trailing: boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    this._hasValue = true;\n    this._sendValue = value;\n\n    if (!this._throttled) {\n      if (this._leading) {\n        this.send();\n      } else {\n        this.throttle(value);\n      }\n    }\n  }\n\n  private send() {\n    const { _hasValue, _sendValue } = this;\n    if (_hasValue) {\n      this.destination.next(_sendValue);\n      this.throttle(_sendValue);\n    }\n    this._hasValue = false;\n    this._sendValue = null;\n  }\n\n  private throttle(value: T): void {\n    const duration = this.tryDurationSelector(value);\n    if (duration) {\n      this.add(this._throttled = subscribeToResult(this, duration));\n    }\n  }\n\n  private tryDurationSelector(value: T): SubscribableOrPromise<any> {\n    try {\n      return this.durationSelector(value);\n    } catch (err) {\n      this.destination.error(err);\n      return null;\n    }\n  }\n\n  private throttlingDone() {\n    const { _throttled, _trailing } = this;\n    if (_throttled) {\n      _throttled.unsubscribe();\n    }\n    this._throttled = null;\n\n    if (_trailing) {\n      this.send();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.throttlingDone();\n  }\n\n  notifyComplete(): void {\n    this.throttlingDone();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { async } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { ThrottleConfig, defaultThrottleConfig } from './throttle';\nimport { MonoTypeOperatorFunction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * <img src=\"./img/throttleTime.png\" width=\"100%\">\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link IScheduler} for managing timers.\n *\n * ## Example\n * Emit clicks at a rate of at most one click per second\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(throttleTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {number} duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the throttling.\n * @param {Object} config a configuration object to define `leading` and\n * `trailing` behavior. Defaults to `{ leading: true, trailing: false }`.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttleTime\n * @owner Observable\n */\nexport function throttleTime<T>(duration: number,\n                                scheduler: SchedulerLike = async,\n                                config: ThrottleConfig = defaultThrottleConfig): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));\n}\n\nclass ThrottleTimeOperator<T> implements Operator<T, T> {\n  constructor(private duration: number,\n              private scheduler: SchedulerLike,\n              private leading: boolean,\n              private trailing: boolean) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(\n      new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing)\n    );\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ThrottleTimeSubscriber<T> extends Subscriber<T> {\n  private throttled: Subscription;\n  private _hasTrailingValue: boolean = false;\n  private _trailingValue: T = null;\n\n  constructor(destination: Subscriber<T>,\n              private duration: number,\n              private scheduler: SchedulerLike,\n              private leading: boolean,\n              private trailing: boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    if (this.throttled) {\n      if (this.trailing) {\n        this._trailingValue = value;\n        this._hasTrailingValue = true;\n      }\n    } else {\n      this.add(this.throttled = this.scheduler.schedule<DispatchArg<T>>(dispatchNext, this.duration, { subscriber: this }));\n      if (this.leading) {\n        this.destination.next(value);\n      }\n    }\n  }\n\n  protected _complete() {\n    if (this._hasTrailingValue) {\n      this.destination.next(this._trailingValue);\n      this.destination.complete();\n    } else {\n      this.destination.complete();\n    }\n  }\n\n  clearThrottle() {\n    const throttled = this.throttled;\n    if (throttled) {\n      if (this.trailing && this._hasTrailingValue) {\n        this.destination.next(this._trailingValue);\n        this._trailingValue = null;\n        this._hasTrailingValue = false;\n      }\n      throttled.unsubscribe();\n      this.remove(throttled);\n      this.throttled = null;\n    }\n  }\n}\n\ninterface DispatchArg<T> {\n  subscriber: ThrottleTimeSubscriber<T>;\n}\n\nfunction dispatchNext<T>(arg: DispatchArg<T>) {\n  const { subscriber } = arg;\n  subscriber.clearThrottle();\n}\n","/**\n * An error thrown when duetime elapses.\n *\n * @see {@link timeout}\n *\n * @class TimeoutError\n */\nexport class TimeoutError extends Error {\n\n  public readonly name = 'TimeoutError';\n\n  constructor() {\n    super('Timeout has occurred');\n    (Object as any).setPrototypeOf(this, TimeoutError.prototype);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { async } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { isDate } from '../util/isDate';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { ObservableInput, OperatorFunction, MonoTypeOperatorFunction, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function timeoutWith<T, R>(due: number | Date, withObservable: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>;\n/* tslint:enable:max-line-length */\n\n/**\n *\n * Errors if Observable does not emit a value in given time span, in case of which\n * subscribes to the second Observable.\n *\n * <span class=\"informal\">It's a version of `timeout` operator that let's you specify fallback Observable.</span>\n *\n * <img src=\"./img/timeoutWith.png\" width=\"100%\">\n *\n * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,\n * still accepting as a first argument either a number or a Date, which control - respectively -\n * when values of source Observable should be emitted or when it should complete.\n *\n * The only difference is that it accepts a second, required parameter. This parameter\n * should be an Observable which will be subscribed when source Observable fails any timeout check.\n * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting\n * values from second Observable. Note that this fallback Observable is not checked for timeouts\n * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second\n * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that\n * stream completes, it completes as well.\n *\n * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided\n * here - as a third, optional parameter. It still is used to schedule timeout checks and -\n * as a consequence - when second Observable will be subscribed, since subscription happens\n * immediately after failing check.\n *\n * ## Example\n * Add fallback observable\n * ```javascript\n * const seconds = interval(1000);\n * const minutes = interval(60 * 1000);\n *\n * seconds.pipe(timeoutWith(900, minutes))\n *   .subscribe(\n *     value => console.log(value), // After 900ms, will start emitting `minutes`,\n *                                  // since first value of `seconds` will not arrive fast enough.\n *     err => console.log(err),     // Would be called after 900ms in case of `timeout`,\n *                                  // but here will never be called.\n *   );\n * ```\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable\n *                          passed as a second parameter.\n * @method timeoutWith\n * @owner Observable\n */\nexport function timeoutWith<T, R>(due: number | Date,\n                                  withObservable: ObservableInput<R>,\n                                  scheduler: SchedulerLike = async): OperatorFunction<T, T | R> {\n  return (source: Observable<T>) => {\n    let absoluteTimeout = isDate(due);\n    let waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(<number>due);\n    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n  };\n}\n\nclass TimeoutWithOperator<T> implements Operator<T, T> {\n  constructor(private waitFor: number,\n              private absoluteTimeout: boolean,\n              private withObservable: ObservableInput<any>,\n              private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TimeoutWithSubscriber(\n      subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TimeoutWithSubscriber<T, R> extends OuterSubscriber<T, R> {\n\n  private action: SchedulerAction<TimeoutWithSubscriber<T, R>> = null;\n\n  constructor(destination: Subscriber<T>,\n              private absoluteTimeout: boolean,\n              private waitFor: number,\n              private withObservable: ObservableInput<any>,\n              private scheduler: SchedulerLike) {\n    super(destination);\n    this.scheduleTimeout();\n  }\n\n  private static dispatchTimeout<T, R>(subscriber: TimeoutWithSubscriber<T, R>): void {\n    const { withObservable } = subscriber;\n    (<any> subscriber)._unsubscribeAndRecycle();\n    subscriber.add(subscribeToResult(subscriber, withObservable));\n  }\n\n  private scheduleTimeout(): void {\n    const { action } = this;\n    if (action) {\n      // Recycle the action if we've already scheduled one. All the production\n      // Scheduler Actions mutate their state/delay time and return themeselves.\n      // VirtualActions are immutable, so they create and return a clone. In this\n      // case, we need to set the action reference to the most recent VirtualAction,\n      // to ensure that's the one we clone from next time.\n      this.action = (<SchedulerAction<TimeoutWithSubscriber<T, R>>> action.schedule(this, this.waitFor));\n    } else {\n      this.add(this.action = (<SchedulerAction<TimeoutWithSubscriber<T, R>>> this.scheduler.schedule<TimeoutWithSubscriber<T, R>>(\n        TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this\n      )));\n    }\n  }\n\n  protected _next(value: T): void {\n    if (!this.absoluteTimeout) {\n      this.scheduleTimeout();\n    }\n    super._next(value);\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    this.action = null;\n    this.scheduler = null;\n    this.withObservable = null;\n  }\n}\n","import { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\nimport { Subject } from '../Subject';\nimport { Subscriber } from '../Subscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { Operator } from '../Operator';\n\n/**\n * Branch out the source Observable values as a nested Observable whenever\n * `windowBoundaries` emits.\n *\n * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n * instead of an array.</span>\n *\n * <img src=\"./img/window.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping\n * windows. It emits the current window and opens a new one whenever the\n * Observable `windowBoundaries` emits an item. Because each window is an\n * Observable, the output is a higher-order Observable.\n *\n * ## Example\n * In every window of 1 second each, emit at most 2 click events\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const interval = interval(1000);\n * const result = clicks.pipe(\n *   window(interval),\n *   map(win => win.take(2)), // each window has at most 2 emissions\n *   mergeAll(),              // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link buffer}\n *\n * @param {Observable<any>} windowBoundaries An Observable that completes the\n * previous window and starts a new window.\n * @return {Observable<Observable<T>>} An Observable of windows, which are\n * Observables emitting values of the source Observable.\n * @method window\n * @owner Observable\n */\nexport function window<T>(windowBoundaries: Observable<any>): OperatorFunction<T, Observable<T>> {\n  return function windowOperatorFunction(source: Observable<T>) {\n    return source.lift(new WindowOperator(windowBoundaries));\n  };\n}\n\nclass WindowOperator<T> implements Operator<T, Observable<T>> {\n\n  constructor(private windowBoundaries: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    const windowSubscriber = new WindowSubscriber(subscriber);\n    const sourceSubscription = source.subscribe(windowSubscriber);\n    if (!sourceSubscription.closed) {\n      windowSubscriber.add(subscribeToResult(windowSubscriber, this.windowBoundaries));\n    }\n    return sourceSubscription;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowSubscriber<T> extends OuterSubscriber<T, any> {\n\n  private window: Subject<T> = new Subject<T>();\n\n  constructor(destination: Subscriber<Observable<T>>) {\n    super(destination);\n    destination.next(this.window);\n  }\n\n  notifyNext(outerValue: T, innerValue: any,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, any>): void {\n    this.openWindow();\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, any>): void {\n    this._error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, any>): void {\n    this._complete();\n  }\n\n  protected _next(value: T): void {\n    this.window.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.window.error(err);\n    this.destination.error(err);\n  }\n\n  protected _complete(): void {\n    this.window.complete();\n    this.destination.complete();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    this.window = null;\n  }\n\n  private openWindow(): void  {\n    const prevWindow = this.window;\n    if (prevWindow) {\n      prevWindow.complete();\n    }\n    const destination = this.destination;\n    const newWindow = this.window = new Subject<T>();\n    destination.next(newWindow);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { OperatorFunction } from '../types';\n\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowCount.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * ## Examples\n * Ignore every 3rd click event, starting from the first one\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowCount(3)),\n *   map(win => win.skip(1)), // skip first of every 3 clicks\n *   mergeAll(),              // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Ignore every 3rd click event, starting from the third one\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowCount(2, 3),\n *   mergeAll(),              // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n * are Observable of values.\n * @method windowCount\n * @owner Observable\n */\nexport function windowCount<T>(windowSize: number,\n                               startWindowEvery: number = 0): OperatorFunction<T, Observable<T>> {\n  return function windowCountOperatorFunction(source: Observable<T>) {\n    return source.lift(new WindowCountOperator<T>(windowSize, startWindowEvery));\n  };\n}\n\nclass WindowCountOperator<T> implements Operator<T, Observable<T>> {\n\n  constructor(private windowSize: number,\n              private startWindowEvery: number) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowCountSubscriber<T> extends Subscriber<T> {\n  private windows: Subject<T>[] = [ new Subject<T>() ];\n  private count: number = 0;\n\n  constructor(protected destination: Subscriber<Observable<T>>,\n              private windowSize: number,\n              private startWindowEvery: number) {\n    super(destination);\n    destination.next(this.windows[0]);\n  }\n\n  protected _next(value: T) {\n    const startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;\n    const destination = this.destination;\n    const windowSize = this.windowSize;\n    const windows = this.windows;\n    const len = windows.length;\n\n    for (let i = 0; i < len && !this.closed; i++) {\n      windows[i].next(value);\n    }\n    const c = this.count - windowSize + 1;\n    if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n      windows.shift().complete();\n    }\n    if (++this.count % startWindowEvery === 0 && !this.closed) {\n      const window = new Subject<T>();\n      windows.push(window);\n      destination.next(window);\n    }\n  }\n\n  protected _error(err: any) {\n    const windows = this.windows;\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().error(err);\n      }\n    }\n    this.destination.error(err);\n  }\n\n  protected _complete() {\n    const windows = this.windows;\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().complete();\n      }\n    }\n    this.destination.complete();\n  }\n\n  protected _unsubscribe() {\n    this.count = 0;\n    this.windows = null;\n  }\n}\n","import { Observable } from '../Observable';\nimport { fromArray } from './fromArray';\nimport { isArray } from '../util/isArray';\nimport { Operator } from '../Operator';\nimport { ObservableInput, PartialObserver } from '../types';\nimport { Subscriber } from '../Subscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { iterator as Symbol_iterator } from '../../internal/symbol/iterator';\n\n/* tslint:disable:max-line-length */\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<T, R>(v1: ObservableInput<T>, resultSelector: (v1: T) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<T, T2, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, resultSelector: (v1: T, v2: T2) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<T, T2, T3, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<T, T2, T3, T4, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<T, T2, T3, T4, T5, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<T, T2, T3, T4, T5, T6, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): Observable<R>;\n\nexport function zip<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;\nexport function zip<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;\nexport function zip<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;\nexport function zip<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;\nexport function zip<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;\n\nexport function zip<T>(array: ObservableInput<T>[]): Observable<T[]>;\nexport function zip<R>(array: ObservableInput<any>[]): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<T, R>(array: ObservableInput<T>[], resultSelector: (...values: Array<T>) => R): Observable<R>;\n/** @deprecated resultSelector is no longer supported, pipe to map instead */\nexport function zip<R>(array: ObservableInput<any>[], resultSelector: (...values: Array<any>) => R): Observable<R>;\n\nexport function zip<T>(...observables: Array<ObservableInput<T>>): Observable<T[]>;\nexport function zip<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): Observable<R>;\nexport function zip<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n * of its input Observables.\n *\n * If the latest parameter is a function, this function is used to compute the created value from the input values.\n * Otherwise, an array of the input values is returned.\n *\n * ## Example\n * Combine age and name from different sources\n * ```javascript\n * let age$ = of<number>(27, 25, 29);\n * let name$ = of<string>('Foo', 'Bar', 'Beer');\n * let isDev$ = of<boolean>(true, true, false);\n *\n * zip(age$, name$, isDev$).pipe(\n *   map((age: number, name: string, isDev: boolean) => ({ age, name, isDev })),\n * )\n * .subscribe(x => console.log(x));\n *\n * // outputs\n * // { age: 27, name: 'Foo', isDev: true }\n * // { age: 25, name: 'Bar', isDev: true }\n * // { age: 29, name: 'Beer', isDev: false }\n * ```\n * @param observables\n * @return {Observable<R>}\n * @static true\n * @name zip\n * @owner Observable\n */\nexport function zip<T, R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R> {\n  const resultSelector = <((...ys: Array<any>) => R)> observables[observables.length - 1];\n  if (typeof resultSelector === 'function') {\n    observables.pop();\n  }\n  return fromArray(observables, undefined).lift(new ZipOperator(resultSelector));\n}\n\nexport class ZipOperator<T, R> implements Operator<T, R> {\n\n  resultSelector: (...values: Array<any>) => R;\n\n  constructor(resultSelector?: (...values: Array<any>) => R) {\n    this.resultSelector = resultSelector;\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class ZipSubscriber<T, R> extends Subscriber<T> {\n  private values: any;\n  private resultSelector: (...values: Array<any>) => R;\n  private iterators: LookAheadIterator<any>[] = [];\n  private active = 0;\n\n  constructor(destination: Subscriber<R>,\n              resultSelector?: (...values: Array<any>) => R,\n              values: any = Object.create(null)) {\n    super(destination);\n    this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : null;\n    this.values = values;\n  }\n\n  protected _next(value: any) {\n    const iterators = this.iterators;\n    if (isArray(value)) {\n      iterators.push(new StaticArrayIterator(value));\n    } else if (typeof value[Symbol_iterator] === 'function') {\n      iterators.push(new StaticIterator(value[Symbol_iterator]()));\n    } else {\n      iterators.push(new ZipBufferIterator(this.destination, this, value));\n    }\n  }\n\n  protected _complete() {\n    const iterators = this.iterators;\n    const len = iterators.length;\n\n    if (len === 0) {\n      this.destination.complete();\n      return;\n    }\n\n    this.active = len;\n    for (let i = 0; i < len; i++) {\n      let iterator: ZipBufferIterator<any, any> = <any>iterators[i];\n      if (iterator.stillUnsubscribed) {\n        this.add(iterator.subscribe(iterator, i));\n      } else {\n        this.active--; // not an observable\n      }\n    }\n  }\n\n  notifyInactive() {\n    this.active--;\n    if (this.active === 0) {\n      this.destination.complete();\n    }\n  }\n\n  checkIterators() {\n    const iterators = this.iterators;\n    const len = iterators.length;\n    const destination = this.destination;\n\n    // abort if not all of them have values\n    for (let i = 0; i < len; i++) {\n      let iterator = iterators[i];\n      if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n        return;\n      }\n    }\n\n    let shouldComplete = false;\n    const args: any[] = [];\n    for (let i = 0; i < len; i++) {\n      let iterator = iterators[i];\n      let result = iterator.next();\n\n      // check to see if it's completed now that you've gotten\n      // the next value.\n      if (iterator.hasCompleted()) {\n        shouldComplete = true;\n      }\n\n      if (result.done) {\n        destination.complete();\n        return;\n      }\n\n      args.push(result.value);\n    }\n\n    if (this.resultSelector) {\n      this._tryresultSelector(args);\n    } else {\n      destination.next(args);\n    }\n\n    if (shouldComplete) {\n      destination.complete();\n    }\n  }\n\n  protected _tryresultSelector(args: any[]) {\n    let result: any;\n    try {\n      result = this.resultSelector.apply(this, args);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n\ninterface LookAheadIterator<T> extends Iterator<T> {\n  hasValue(): boolean;\n  hasCompleted(): boolean;\n}\n\nclass StaticIterator<T> implements LookAheadIterator<T> {\n  private nextResult: IteratorResult<T>;\n\n  constructor(private iterator: Iterator<T>) {\n    this.nextResult = iterator.next();\n  }\n\n  hasValue() {\n    return true;\n  }\n\n  next(): IteratorResult<T> {\n    const result = this.nextResult;\n    this.nextResult = this.iterator.next();\n    return result;\n  }\n\n  hasCompleted() {\n    const nextResult = this.nextResult;\n    return nextResult && nextResult.done;\n  }\n}\n\nclass StaticArrayIterator<T> implements LookAheadIterator<T> {\n  private index = 0;\n  private length = 0;\n\n  constructor(private array: T[]) {\n    this.length = array.length;\n  }\n\n  [Symbol_iterator]() {\n    return this;\n  }\n\n  next(value?: any): IteratorResult<T> {\n    const i = this.index++;\n    const array = this.array;\n    return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\n  }\n\n  hasValue() {\n    return this.array.length > this.index;\n  }\n\n  hasCompleted() {\n    return this.array.length === this.index;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ZipBufferIterator<T, R> extends OuterSubscriber<T, R> implements LookAheadIterator<T> {\n  stillUnsubscribed = true;\n  buffer: T[] = [];\n  isComplete = false;\n\n  constructor(destination: PartialObserver<T>,\n              private parent: ZipSubscriber<T, R>,\n              private observable: Observable<T>) {\n    super(destination);\n  }\n\n  [Symbol_iterator]() {\n    return this;\n  }\n\n  // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next\n  //    this is legit because `next()` will never be called by a subscription in this case.\n  next(): IteratorResult<T> {\n    const buffer = this.buffer;\n    if (buffer.length === 0 && this.isComplete) {\n      return { value: null, done: true };\n    } else {\n      return { value: buffer.shift(), done: false };\n    }\n  }\n\n  hasValue() {\n    return this.buffer.length > 0;\n  }\n\n  hasCompleted() {\n    return this.buffer.length === 0 && this.isComplete;\n  }\n\n  notifyComplete() {\n    if (this.buffer.length > 0) {\n      this.isComplete = true;\n      this.parent.notifyInactive();\n    } else {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: any,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.buffer.push(innerValue);\n    this.parent.checkIterators();\n  }\n\n  subscribe(value: any, index: number) {\n    return subscribeToResult<any, any>(this, this.observable, this, index);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../types';\n\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowToggle.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * ## Example\n * Every other second, emit the click events from the next 500ms\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const openings = interval(1000);\n * const result = clicks.pipe(\n *   windowToggle(openings, i => i % 2 ? interval(500) : empty()),\n *   mergeAll(),\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\nexport function windowToggle<T, O>(openings: Observable<O>,\n                                   closingSelector: (openValue: O) => Observable<any>): OperatorFunction<T, Observable<T>> {\n  return (source: Observable<T>) => source.lift(new WindowToggleOperator<T, O>(openings, closingSelector));\n}\n\nclass WindowToggleOperator<T, O> implements Operator<T, Observable<T>> {\n\n  constructor(private openings: Observable<O>,\n              private closingSelector: (openValue: O) => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowToggleSubscriber(\n      subscriber, this.openings, this.closingSelector\n    ));\n  }\n}\n\ninterface WindowContext<T> {\n  window: Subject<T>;\n  subscription: Subscription;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowToggleSubscriber<T, O> extends OuterSubscriber<T, any> {\n  private contexts: WindowContext<T>[] = [];\n  private openSubscription: Subscription;\n\n  constructor(destination: Subscriber<Observable<T>>,\n              private openings: Observable<O>,\n              private closingSelector: (openValue: O) => Observable<any>) {\n    super(destination);\n    this.add(this.openSubscription = subscribeToResult(this, openings, openings as any));\n  }\n\n  protected _next(value: T) {\n    const { contexts } = this;\n    if (contexts) {\n      const len = contexts.length;\n      for (let i = 0; i < len; i++) {\n        contexts[i].window.next(value);\n      }\n    }\n  }\n\n  protected _error(err: any) {\n\n    const { contexts } = this;\n    this.contexts = null;\n\n    if (contexts) {\n      const len = contexts.length;\n      let index = -1;\n\n      while (++index < len) {\n        const context = contexts[index];\n        context.window.error(err);\n        context.subscription.unsubscribe();\n      }\n    }\n\n    super._error(err);\n  }\n\n  protected _complete() {\n    const { contexts } = this;\n    this.contexts = null;\n    if (contexts) {\n      const len = contexts.length;\n      let index = -1;\n      while (++index < len) {\n        const context = contexts[index];\n        context.window.complete();\n        context.subscription.unsubscribe();\n      }\n    }\n    super._complete();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    const { contexts } = this;\n    this.contexts = null;\n    if (contexts) {\n      const len = contexts.length;\n      let index = -1;\n      while (++index < len) {\n        const context = contexts[index];\n        context.window.unsubscribe();\n        context.subscription.unsubscribe();\n      }\n    }\n  }\n\n  notifyNext(outerValue: any, innerValue: any,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, any>): void {\n\n    if (outerValue === this.openings) {\n\n      const { closingSelector } = this;\n      const closingNotifier = tryCatch(closingSelector)(innerValue);\n\n      if (closingNotifier === errorObject) {\n        return this.error(errorObject.e);\n      } else {\n        const window = new Subject<T>();\n        const subscription = new Subscription();\n        const context = { window, subscription };\n        this.contexts.push(context);\n        const innerSubscription = subscribeToResult(this, closingNotifier, context as any);\n\n        if (innerSubscription.closed) {\n          this.closeWindow(this.contexts.length - 1);\n        } else {\n          (<any> innerSubscription).context = context;\n          subscription.add(innerSubscription);\n        }\n\n        this.destination.next(window);\n\n      }\n    } else {\n      this.closeWindow(this.contexts.indexOf(outerValue));\n    }\n  }\n\n  notifyError(err: any): void {\n    this.error(err);\n  }\n\n  notifyComplete(inner: Subscription): void {\n    if (inner !== this.openSubscription) {\n      this.closeWindow(this.contexts.indexOf((<any> inner).context));\n    }\n  }\n\n  private closeWindow(index: number): void {\n    if (index === -1) {\n      return;\n    }\n\n    const { contexts } = this;\n    const context = contexts[index];\n    const { window, subscription } = context;\n    contexts.splice(index, 1);\n    window.complete();\n    subscription.unsubscribe();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../types';\n\n/**\n * Branch out the source Observable values as a nested Observable using a\n * factory function of closing Observables to determine when to start a new\n * window.\n *\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowWhen.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping windows.\n * It emits the current window and opens a new one whenever the Observable\n * produced by the specified `closingSelector` function emits an item. The first\n * window is opened immediately when subscribing to the output Observable.\n *\n * ## Example\n * Emit only the first two clicks events in every window of [1-5] random seconds\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowWhen(() => interval(1000 + Math.random() * 4000)),\n *   map(win => win.pipe(take(2))),     // each window has at most 2 emissions\n *   mergeAll(),                        // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link bufferWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals (on either `next` or\n * `complete`) when to close the previous window and start a new one.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowWhen\n * @owner Observable\n */\nexport function windowWhen<T>(closingSelector: () => Observable<any>): OperatorFunction<T, Observable<T>> {\n  return function windowWhenOperatorFunction(source: Observable<T>) {\n    return source.lift(new WindowOperator<T>(closingSelector));\n  };\n}\n\nclass WindowOperator<T> implements Operator<T, Observable<T>> {\n  constructor(private closingSelector: () => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowSubscriber<T> extends OuterSubscriber<T, any> {\n  private window: Subject<T>;\n  private closingNotification: Subscription;\n\n  constructor(protected destination: Subscriber<Observable<T>>,\n              private closingSelector: () => Observable<any>) {\n    super(destination);\n    this.openWindow();\n  }\n\n  notifyNext(outerValue: T, innerValue: any,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, any>): void {\n    this.openWindow(innerSub);\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, any>): void {\n    this._error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, any>): void {\n    this.openWindow(innerSub);\n  }\n\n  protected _next(value: T): void {\n    this.window.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.window.error(err);\n    this.destination.error(err);\n    this.unsubscribeClosingNotification();\n  }\n\n  protected _complete(): void {\n    this.window.complete();\n    this.destination.complete();\n    this.unsubscribeClosingNotification();\n  }\n\n  private unsubscribeClosingNotification(): void {\n    if (this.closingNotification) {\n      this.closingNotification.unsubscribe();\n    }\n  }\n\n  private openWindow(innerSub: InnerSubscriber<T, any> = null): void {\n    if (innerSub) {\n      this.remove(innerSub);\n      innerSub.unsubscribe();\n    }\n\n    const prevWindow = this.window;\n    if (prevWindow) {\n      prevWindow.complete();\n    }\n\n    const window = this.window = new Subject<T>();\n    this.destination.next(window);\n\n    const closingNotifier = tryCatch(this.closingSelector)();\n    if (closingNotifier === errorObject) {\n      const err = errorObject.e;\n      this.destination.error(err);\n      this.window.error(err);\n    } else {\n      this.add(this.closingNotification = subscribeToResult(this, closingNotifier));\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { ObservableInput, OperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function withLatestFrom<T, R>(project: (v1: T) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): OperatorFunction<T, R> ;\nexport function withLatestFrom<T, T2>(v2: ObservableInput<T2>): OperatorFunction<T, [T, T2]>;\nexport function withLatestFrom<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): OperatorFunction<T, [T, T2, T3]>;\nexport function withLatestFrom<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): OperatorFunction<T, [T, T2, T3, T4]>;\nexport function withLatestFrom<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): OperatorFunction<T, [T, T2, T3, T4, T5]>;\nexport function withLatestFrom<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): OperatorFunction<T, [T, T2, T3, T4, T5, T6]> ;\nexport function withLatestFrom<T, R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, R>;\nexport function withLatestFrom<T, R>(array: ObservableInput<any>[]): OperatorFunction<T, R>;\nexport function withLatestFrom<T, R>(array: ObservableInput<any>[], project: (...values: Array<any>) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * ## Example\n * On every click event, emit an array with the latest timer event plus the click event\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const timer = interval(1000);\n * const result = clicks.pipe(withLatestFrom(timer));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatest}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.pipe(withLatestFrom(b, c), map(([a1, b1, c1]) => a1 + b1 + c1))`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method withLatestFrom\n * @owner Observable\n */\nexport function withLatestFrom<T, R>(...args: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, R> {\n  return (source: Observable<T>) => {\n    let project: any;\n    if (typeof args[args.length - 1] === 'function') {\n      project = args.pop();\n    }\n    const observables = <Observable<any>[]>args;\n    return source.lift(new WithLatestFromOperator(observables, project));\n  };\n}\n\nclass WithLatestFromOperator<T, R> implements Operator<T, R> {\n  constructor(private observables: Observable<any>[],\n              private project?: (...values: any[]) => Observable<R>) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WithLatestFromSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private values: any[];\n  private toRespond: number[] = [];\n\n  constructor(destination: Subscriber<R>,\n              private observables: Observable<any>[],\n              private project?: (...values: any[]) => Observable<R>) {\n    super(destination);\n    const len = observables.length;\n    this.values = new Array(len);\n\n    for (let i = 0; i < len; i++) {\n      this.toRespond.push(i);\n    }\n\n    for (let i = 0; i < len; i++) {\n      let observable = observables[i];\n      this.add(subscribeToResult<T, R>(this, observable, <any>observable, i));\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.values[outerIndex] = innerValue;\n    const toRespond = this.toRespond;\n    if (toRespond.length > 0) {\n      const found = toRespond.indexOf(outerIndex);\n      if (found !== -1) {\n        toRespond.splice(found, 1);\n      }\n    }\n  }\n\n  notifyComplete() {\n    // noop\n  }\n\n  protected _next(value: T) {\n    if (this.toRespond.length === 0) {\n      const args = [value, ...this.values];\n      if (this.project) {\n        this._tryProject(args);\n      } else {\n        this.destination.next(args);\n      }\n    }\n  }\n\n  private _tryProject(args: any[]) {\n    let result: any;\n    try {\n      result = this.project.apply(this, args);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","export interface CronJobsBaseFrequency {\n  none: number;\n  minute: number;\n  hour: number;\n  day: number;\n  week: number;\n  month: number;\n  year: number;\n}\n\nexport interface CronJobsConfig {\n  quartz?: boolean;\n  multiple?: boolean;\n  bootstrap?: boolean;\n  option?: {};\n}\n\nexport interface CronJobsFrequency {\n  baseFrequency: number;\n  minutes: Array<number>;\n  hours: Array<number>;\n  daysOfMonth: Array<number>;\n  daysOfWeek: Array<number>;\n  months: Array<number>;\n}\n\nexport interface CronJobsSelectOption {\n  value: number;\n  type?: OptionType;\n  label: string | number;\n}\nexport type OptionType = number;\nexport let OptionType: any = {};\nOptionType.minute = 0;\nOptionType.hour = 1;\nOptionType.day = 2;\nOptionType.week = 3;\nOptionType.month = 4;\nOptionType.year = 5;\nOptionType[OptionType.minute] = \"minute\";\nOptionType[OptionType.hour] = \"hour\";\nOptionType[OptionType.day] = \"day\";\nOptionType[OptionType.week] = \"week\";\nOptionType[OptionType.month] = \"month\";\nOptionType[OptionType.year] = \"year\";\n\n\nexport interface CronJobsValidationConfig {\n  validate?: boolean;\n}\n","import { Injectable } from '@angular/core';\nimport { CronJobsConfig, CronJobsSelectOption, CronJobsValidationConfig, OptionType } from '../contracts/contracts';\nexport class DataService {\nprivate defaultConfig: CronJobsConfig = {\n    quartz: false,\n    bootstrap: true,\n    multiple: false,\n  };\nprivate defaultValidateConfig: CronJobsValidationConfig = {\n    validate: false,\n  };\nprivate daysOfWeekPosix: Array<CronJobsSelectOption> = [\n    {value: 0, label: 'Sunday'},\n    {value: 1, label: 'Monday'},\n    {value: 2, label: 'Tuesday'},\n    {value: 3, label: 'Wednesday'},\n    {value: 4, label: 'Thursday'},\n    {value: 5, label: 'Friday'},\n    {value: 6, label: 'Saturday'}\n  ];\nprivate daysOfWeekQuartz: Array<CronJobsSelectOption> = [\n    {value: 1, label: 'Sunday'},\n    {value: 2, label: 'Monday'},\n    {value: 3, label: 'Tuesday'},\n    {value: 4, label: 'Wednesday'},\n    {value: 5, label: 'Thursday'},\n    {value: 6, label: 'Friday'},\n    {value: 7, label: 'Saturday'}\n  ];\nprivate numeral: Array<CronJobsSelectOption> = [\n    {value: 1, label: '1st'},\n    {value: 2, label: '2nd'},\n    {value: 3, label: '3rd'},\n    {value: 4, label: '4th'},\n    {value: 5, label: '5th'},\n    {value: 6, label: '6th'},\n    {value: 7, label: '7th'},\n    {value: 8, label: '8th'},\n    {value: 9, label: '9th'},\n    {value: 10, label: '10th'},\n    {value: 11, label: '11th'},\n    {value: 12, label: '12th'},\n    {value: 13, label: '13th'},\n    {value: 14, label: '14th'},\n    {value: 15, label: '15th'},\n    {value: 16, label: '16th'},\n    {value: 17, label: '17th'},\n    {value: 18, label: '18th'},\n    {value: 19, label: '19th'},\n    {value: 20, label: '20th'},\n    {value: 21, label: '21st'},\n    {value: 22, label: '22nd'},\n    {value: 23, label: '23rd'},\n    {value: 24, label: '24th'},\n    {value: 25, label: '25th'},\n    {value: 26, label: '26th'},\n    {value: 27, label: '27th'},\n    {value: 28, label: '28th'},\n    {value: 29, label: '29th'},\n    {value: 30, label: '30th'},\n    {value: 31, label: '31st'}\n  ];\nprivate _months: Array<CronJobsSelectOption> = [\n    {value: 1, label: 'January'},\n    {value: 2, label: 'February'},\n    {value: 3, label: 'March'},\n    {value: 4, label: 'April'},\n    {value: 5, label: 'May'},\n    {value: 6, label: 'June'},\n    {value: 7, label: 'July'},\n    {value: 8, label: 'August'},\n    {value: 9, label: 'September'},\n    {value: 10, label: 'October'},\n    {value: 11, label: 'November'},\n    {value: 12, label: 'December'}\n  ];\nprivate _baseFrequency: Array<CronJobsSelectOption> = [\n    { value: 0, label: 'Please select' },\n    { value: 1, type: OptionType.minute, label: 'Minute' },\n    { value: 2, type: OptionType.hour, label: 'Hour' },\n    { value: 3, type: OptionType.day, label: 'Day' },\n    { value: 4, type: OptionType.week, label: 'Week' },\n    { value: 5, type: OptionType.month, label: 'Month' },\n    { value: 6, type: OptionType.year, label: 'Year' }\n  ];\nprivate _hours: Array<CronJobsSelectOption>;\nprivate _minutes: Array<CronJobsSelectOption>;\n/**\n * @return {?}\n */\npublic get baseFrequency(): Array<CronJobsSelectOption> {\n    return [\n      ...this._baseFrequency\n    ];\n  }\n/**\n * @return {?}\n */\npublic get daysOfMonth(): Array<CronJobsSelectOption> {\n    return [\n      ...this.numeral\n    ];\n  }\n/**\n * @return {?}\n */\npublic get months(): Array<CronJobsSelectOption> {\n    return [\n      ...this._months\n    ];\n  }\n/**\n * @return {?}\n */\npublic get hours(): Array<CronJobsSelectOption> {\n    return [\n      ...this._hours\n    ];\n  }\n/**\n * @return {?}\n */\npublic get minutes(): Array<CronJobsSelectOption> {\n    return [\n      ...this._minutes\n    ];\n  }\nconstructor() {\n    this._hours = [];\n    for (let x = 0; x < 24; x++) {\n      this._hours.push(<CronJobsSelectOption>{value: x, label: `${x}`});\n    }\n\n    this._minutes = [];\n    for (let x = 0; x < 60; x = x + 5) {\n      this._minutes.push(<CronJobsSelectOption>{value: x, label: `${x}`});\n    }\n\n  }\n/**\n * @param {?=} config\n * @return {?}\n */\ngetConfig(config: CronJobsConfig = {}): CronJobsConfig {\n    return {\n      ...this.defaultConfig,\n      ...config\n    };\n  }\n/**\n * @param {?=} validateConfig\n * @return {?}\n */\ngetValidate(validateConfig: CronJobsValidationConfig = {}): CronJobsValidationConfig {\n    return {\n      ...this.defaultValidateConfig,\n      ...validateConfig\n    };\n  }\n/**\n * @param {?=} quartz\n * @return {?}\n */\ngetDaysOfWeek(quartz: Boolean = false): Array<CronJobsSelectOption> {\n    if (quartz) {\n      return [\n        ...this.daysOfWeekQuartz\n      ];\n    }\n    return [\n      ...this.daysOfWeekPosix\n    ];\n  }\n\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction DataService_tsickle_Closure_declarations() {\n/** @type {?} */\nDataService.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nDataService.ctorParameters;\n/** @type {?} */\nDataService.prototype.defaultConfig;\n/** @type {?} */\nDataService.prototype.defaultValidateConfig;\n/** @type {?} */\nDataService.prototype.daysOfWeekPosix;\n/** @type {?} */\nDataService.prototype.daysOfWeekQuartz;\n/** @type {?} */\nDataService.prototype.numeral;\n/** @type {?} */\nDataService.prototype._months;\n/** @type {?} */\nDataService.prototype._baseFrequency;\n/** @type {?} */\nDataService.prototype._hours;\n/** @type {?} */\nDataService.prototype._minutes;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nimport { SchedulerAction } from '../types';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AnimationFrameAction<T> extends AsyncAction<T> {\n\n  constructor(protected scheduler: AnimationFrameScheduler,\n              protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AnimationFrameScheduler, id?: any, delay: number = 0): any {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If an animation frame has already been requested, don't request another\n    // one. If an animation frame hasn't been requested yet, request one. Return\n    // the current animation frame request id.\n    return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(\n      () => scheduler.flush(null)));\n  }\n  protected recycleAsyncId(scheduler: AnimationFrameScheduler, id?: any, delay: number = 0): any {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue is empty, cancel the requested animation frame and\n    // set the scheduled flag to undefined so the next AnimationFrameAction will\n    // request its own.\n    if (scheduler.actions.length === 0) {\n      cancelAnimationFrame(id);\n      scheduler.scheduled = undefined;\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { SchedulerAction } from '../types';\n\nexport class VirtualTimeScheduler extends AsyncScheduler {\n\n  protected static frameTimeFactor: number = 10;\n\n  public frame: number = 0;\n  public index: number = -1;\n\n  constructor(SchedulerAction: typeof AsyncAction = VirtualAction as any,\n              public maxFrames: number = Number.POSITIVE_INFINITY) {\n    super(SchedulerAction, () => this.frame);\n  }\n\n  /**\n   * Prompt the Scheduler to execute all of its queued actions, therefore\n   * clearing its queue.\n   * @return {void}\n   */\n  public flush(): void {\n\n    const {actions, maxFrames} = this;\n    let error: any, action: AsyncAction<any>;\n\n    while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    }\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class VirtualAction<T> extends AsyncAction<T> {\n\n  protected active: boolean = true;\n\n  constructor(protected scheduler: VirtualTimeScheduler,\n              protected work: (this: SchedulerAction<T>, state?: T) => void,\n              protected index: number = scheduler.index += 1) {\n    super(scheduler, work);\n    this.index = scheduler.index = index;\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (!this.id) {\n      return super.schedule(state, delay);\n    }\n    this.active = false;\n    // If an action is rescheduled, we save allocations by mutating its state,\n    // pushing it to the end of the scheduler queue, and recycling the action.\n    // But since the VirtualTimeScheduler is used for testing, VirtualActions\n    // must be immutable so they can be inspected later.\n    const action = new VirtualAction(this.scheduler, this.work);\n    this.add(action);\n    return action.schedule(state, delay);\n  }\n\n  protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): any {\n    this.delay = scheduler.frame + delay;\n    const {actions} = scheduler;\n    actions.push(this);\n    (actions as Array<VirtualAction<T>>).sort(VirtualAction.sortActions);\n    return true;\n  }\n\n  protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): any {\n    return undefined;\n  }\n\n  protected _execute(state: T, delay: number): any {\n    if (this.active === true) {\n      return super._execute(state, delay);\n    }\n  }\n\n  public static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n}\n","import { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\n\n/**\n *\n * Animation Frame Scheduler\n *\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n *\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link async} scheduler\n * behaviour.\n *\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\n * It makes sure scheduled task will happen just before next browser content repaint,\n * thus performing animations as efficiently as possible.\n *\n * ## Example\n * Schedule div height animation\n * ```javascript\n * const div = document.querySelector('.some-div');\n *\n * Rx.Scheduler.animationFrame.schedule(function(height) {\n *   div.style.height = height + \"px\";\n *\n *   this.schedule(height + 1);  // `this` references currently executing Action,\n *                               // which we reschedule with new state\n * }, 0, 0);\n *\n * // You will see .some-div element growing in height\n * ```\n *\n * @static true\n * @name animationFrame\n * @owner Scheduler\n */\n\nexport const animationFrame = new AnimationFrameScheduler(AnimationFrameAction);\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AnimationFrameScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n\n    this.active = true;\n    this.scheduled = undefined;\n\n    const {actions} = this;\n    let error: any;\n    let index: number = -1;\n    let count: number = actions.length;\n    action = action || actions.shift();\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (++index < count && (action = actions.shift()));\n\n    this.active = false;\n\n    if (error) {\n      while (++index < count && (action = actions.shift())) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { CronJobsBaseFrequency, CronJobsFrequency, CronJobsSelectOption } from '../contracts/contracts';\nimport { DataService } from './data.service';\nexport class PosixService {\npublic baseFrequency: CronJobsBaseFrequency;\nprivate frequencyData: Array<CronJobsSelectOption>;\n/**\n * @param {?} dataService\n */\nconstructor(protected dataService: DataService) {\n    this.frequencyData = this.dataService.baseFrequency;\n    const keys = ['none', 'minute', 'hour', 'day', 'week', 'month', 'year'];\n    const result = {};\n    keys.forEach((key: string, idx: number) => {\n      result[key] = this.frequencyData[idx].value;\n    });\n    this.baseFrequency = <CronJobsBaseFrequency>result;\n  }\n/**\n * @return {?}\n */\npublic getDefaultFrequency(): CronJobsFrequency {\n    const /** @type {?} */ cronJobsFrequency = {\n      baseFrequency: this.frequencyData[0].value,\n      minutes: [],\n      hours: [],\n      daysOfMonth: [],\n      daysOfWeek: [],\n      months: []\n    };\n    return cronJobsFrequency;\n  }\n/**\n * @return {?}\n */\npublic getDefaultFrequenceWithDefault(): CronJobsFrequency {\n    const /** @type {?} */ cronJobsFrequency = this.getDefaultFrequency();\n    cronJobsFrequency.daysOfWeek = this.getDaysOfWeek()[0] ? [this.getDaysOfWeek()[0].value] : [];\n    cronJobsFrequency.daysOfMonth = this.dataService.daysOfMonth[0] ? [this.dataService.daysOfMonth[0].value] : [];\n    cronJobsFrequency.months = this.dataService.months[0] ? [this.dataService.months[0].value] : [];\n    cronJobsFrequency.hours = this.dataService.hours[0] ? [this.dataService.hours[0].value] : [];\n    cronJobsFrequency.minutes = this.dataService.minutes[0] ? [this.dataService.minutes[0].value] : [];\n    return cronJobsFrequency;\n  }\n/**\n * @return {?}\n */\nprotected getDaysOfWeek(): Array<CronJobsSelectOption> {\n    return this.dataService.getDaysOfWeek(false);\n  }\n/**\n * @param {?} value\n * @return {?}\n */\npublic fromCronWithDefault(value: String): CronJobsFrequency {\n    const /** @type {?} */ cron = value.trim().replace(/\\s+/g, ' ').split(' ');\n    const /** @type {?} */ frequency = this.getDefaultFrequenceWithDefault();\n\n    return this.fromCronInternal(cron, frequency);\n  }\n/**\n * @param {?} value\n * @return {?}\n */\npublic fromCron(value: String): CronJobsFrequency {\n    const /** @type {?} */ cron = value.trim().replace(/\\s+/g, ' ').split(' ');\n    const /** @type {?} */ frequency = this.getDefaultFrequency();\n\n    return this.fromCronInternal(cron, frequency);\n  }\n/**\n * @param {?} cron\n * @param {?} frequency\n * @return {?}\n */\nprivate fromCronInternal(cron: string[], frequency: CronJobsFrequency): CronJobsFrequency {\n    if (cron.length !== 5) {\n      return frequency;\n    }\n\n    if (cron[0] === '*' && cron[1] === '*' && cron[2] === '*' && cron[3] === '*' && cron[4] === '*') {\n      frequency.baseFrequency = this.baseFrequency.minute; // every minute\n    } else if (cron[1] === '*' && cron[2] === '*' && cron[3] === '*' && cron[4] === '*') {\n      frequency.baseFrequency = this.baseFrequency.hour; // every hour\n    } else if (cron[2] === '*' && cron[3] === '*' && cron[4] === '*') {\n      frequency.baseFrequency = this.baseFrequency.day; // every day\n    } else if (cron[2] === '*' && cron[3] === '*') {\n      frequency.baseFrequency = this.baseFrequency.week; // every week\n    } else if (cron[3] === '*' && cron[4] === '*') {\n      frequency.baseFrequency = this.baseFrequency.month; // every month\n    } else if (cron[4] === '*') {\n      frequency.baseFrequency = this.baseFrequency.year; // every year\n    }\n    if (cron[0] !== '*') {\n      // preparing to handle multiple minutes\n      frequency.minutes = this.getValueArray(cron[0]);\n    }\n    if (cron[1] !== '*') {\n      // preparing to handle multiple hours\n      frequency.hours = this.getValueArray(cron[1]);\n    }\n    if (cron[2] !== '*') {\n      // preparing to handle multiple daysOfWeek of the month\n      frequency.daysOfMonth = this.getValueArray(cron[2]);\n    }\n    if (cron[3] !== '*') {\n      // preparing to handle multiple months\n      frequency.months = this.getValueArray(cron[3]);\n    }\n    if (cron[4] !== '*') {\n      // preparing to handle multiple daysOfWeek of the week\n      frequency.daysOfWeek = this.getValueArray(cron[4]);\n    }\n    return frequency;\n  }\n/**\n * @param {?} value\n * @return {?}\n */\nsetCron(value: CronJobsFrequency) {\n    const /** @type {?} */ cron = ['*', '*', '*', '*', '*'];\n\n    if (value && value.baseFrequency) {\n      if (value.baseFrequency >= this.baseFrequency.hour) {\n        cron[0] = value.minutes.length > 0 ? value.minutes.join(',') : '*';\n      }\n\n      if (value.baseFrequency >= this.baseFrequency.day) {\n        cron[1] = value.hours.length > 0 ? value.hours.join(',') : '*';\n      }\n\n      if (value.baseFrequency === this.baseFrequency.week) {\n        cron[4] = value.daysOfWeek.length > 0 ? value.daysOfWeek.join(',') : '*';\n      }\n\n      if (value.baseFrequency >= this.baseFrequency.month) {\n        cron[2] = value.daysOfMonth.length > 0 ? value.daysOfMonth.join(',') : '*';\n      }\n\n      if (value.baseFrequency === this.baseFrequency.year) {\n        cron[3] = value.months.length > 0 ? value.months.join(',') : '*';\n      }\n    } else {\n      return '';\n    }\n\n\n    return cron.join(' ');\n  }\n/**\n * @param {?} value\n * @return {?}\n */\npublic getValueArray(value: string): Array<number> {\n    if (value) {\n      return value.split(',').map((ele) => +ele);\n    }\n    return [];\n  }\n\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: DataService, },\n];\n}\n\nfunction PosixService_tsickle_Closure_declarations() {\n/** @type {?} */\nPosixService.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nPosixService.ctorParameters;\n/** @type {?} */\nPosixService.prototype.baseFrequency;\n/** @type {?} */\nPosixService.prototype.frequencyData;\n/** @type {?} */\nPosixService.prototype.dataService;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput } from '../types';\nimport { isArray } from '../util/isArray';\nimport { EMPTY } from './empty';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { Subscriber } from '../Subscriber';\nimport { map } from '../operators/map';\n\n/* tslint:disable:max-line-length */\n// forkJoin([a$, b$, c$]);\nexport function forkJoin<T>(sources: [ObservableInput<T>]): Observable<T[]>;\nexport function forkJoin<T, T2>(sources: [ObservableInput<T>, ObservableInput<T2>]): Observable<[T, T2]>;\nexport function forkJoin<T, T2, T3>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>]): Observable<[T, T2, T3]>;\nexport function forkJoin<T, T2, T3, T4>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>, ObservableInput<T4>]): Observable<[T, T2, T3, T4]>;\nexport function forkJoin<T, T2, T3, T4, T5>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>, ObservableInput<T4>, ObservableInput<T5>]): Observable<[T, T2, T3, T4, T5]>;\nexport function forkJoin<T, T2, T3, T4, T5, T6>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>, ObservableInput<T4>, ObservableInput<T5>, ObservableInput<T6>]): Observable<[T, T2, T3, T4, T5, T6]>;\nexport function forkJoin<T>(sources: Array<ObservableInput<T>>): Observable<T[]>;\n\n// forkJoin(a$, b$, c$)\nexport function forkJoin<T>(v1: ObservableInput<T>): Observable<T[]>;\nexport function forkJoin<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;\nexport function forkJoin<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;\nexport function forkJoin<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;\nexport function forkJoin<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;\nexport function forkJoin<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;\n\n/** @deprecated resultSelector is deprecated, pipe to map instead */\nexport function forkJoin(...args: Array<ObservableInput<any>|Function>): Observable<any>;\nexport function forkJoin<T>(...sources: ObservableInput<T>[]): Observable<T[]>;\n/* tslint:enable:max-line-length */\n\n/**\n * Joins last values emitted by passed Observables.\n *\n * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\n *\n * <img src=\"./img/forkJoin.png\" width=\"100%\">\n *\n * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array\n * or directly as arguments. If no input Observables are provided, resulting stream will complete\n * immediately.\n *\n * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last\n * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting\n * array will have `n` values, where first value is the last thing emitted by the first Observable,\n * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will\n * not emit more than once and it will complete after that. If you need to emit combined values not only\n * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}\n * or {@link zip} instead.\n *\n * In order for resulting array to have the same length as the number of input Observables, whenever any of\n * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well\n * and it will not emit anything either, even if it already has some last values from other Observables.\n * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,\n * unless at any point some other Observable completes without emitting value, which brings us back to\n * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments\n * have to emit something at least once and complete.\n *\n * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables\n * will be immediately unsubscribed.\n *\n * Optionally `forkJoin` accepts project function, that will be called with values which normally\n * would land in emitted array. Whatever is returned by project function, will appear in output\n * Observable instead. This means that default project can be thought of as a function that takes\n * all its arguments and puts them into an array. Note that project function will be called only\n * when output Observable is supposed to emit a result.\n *\n * ## Examples\n * ### Use forkJoin with operator emitting immediately\n * ```javascript\n * import { forkJoin, of } from 'rxjs';\n *\n * const observable = forkJoin(\n *   of(1, 2, 3, 4),\n *   of(5, 6, 7, 8),\n * );\n * observable.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('This is how it ends!'),\n * );\n *\n * // Logs:\n * // [4, 8]\n * // \"This is how it ends!\"\n * ```\n *\n * ### Use forkJoin with operator emitting after some time\n * ```javascript\n * import { forkJoin, interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const observable = forkJoin(\n *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete\n *   interval(500).pipe(take(4)),  // emit 0, 1, 2, 3 every half a second and complete\n * );\n * observable.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('This is how it ends!'),\n * );\n *\n * // Logs:\n * // [2, 3] after 3 seconds\n * // \"This is how it ends!\" immediately after\n * ```\n *\n * ### Use forkJoin with project function\n * ```javascript\n * import { jorkJoin, interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const observable = forkJoin(\n *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete\n *   interval(500).pipe(take(4)),  // emit 0, 1, 2, 3 every half a second and complete\n * ).pipe(\n *   map(([n, m]) => n + m),\n * );\n * observable.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('This is how it ends!'),\n * );\n *\n * // Logs:\n * // 5 after 3 seconds\n * // \"This is how it ends!\" immediately after\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n *\n * @param {...ObservableInput} sources Any number of Observables provided either as an array or as an arguments\n * passed directly to the operator.\n * @param {function} [project] Function that takes values emitted by input Observables and returns value\n * that will appear in resulting Observable instead of default array.\n * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\n * or value from project function.\n */\nexport function forkJoin<T>(\n  ...sources: Array<ObservableInput<T> | ObservableInput<T>[] | Function>\n): Observable<T[]> {\n\n  let resultSelector: Function;\n  if (typeof sources[sources.length - 1] === 'function') {\n    // DEPRECATED PATH\n    resultSelector = sources.pop() as Function;\n  }\n\n  // if the first and only other argument is an array\n  // assume it's been called with `forkJoin([obs1, obs2, obs3])`\n  if (sources.length === 1 && isArray(sources[0])) {\n    sources = sources[0] as Array<ObservableInput<T>>;\n  }\n\n  if (sources.length === 0) {\n    return EMPTY;\n  }\n\n  if (resultSelector) {\n    // DEPRECATED PATH\n    return forkJoin(sources).pipe(\n      map(args => resultSelector(...args))\n    );\n  }\n\n  return new Observable(subscriber => {\n    return new ForkJoinSubscriber(subscriber, sources as Array<ObservableInput<T>>);\n  });\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ForkJoinSubscriber<T, R> extends OuterSubscriber<T, T> {\n  private completed = 0;\n  private values: T[];\n  private haveValues = 0;\n\n  constructor(destination: Subscriber<R>,\n              private sources: Array<ObservableInput<T>>) {\n    super(destination);\n\n    const len = sources.length;\n    this.values = new Array(len);\n\n    for (let i = 0; i < len; i++) {\n      const source = sources[i];\n      const innerSubscription = subscribeToResult(this, source, null, i);\n\n      if (innerSubscription) {\n        this.add(innerSubscription);\n      }\n    }\n  }\n\n  notifyNext(outerValue: any, innerValue: T,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, T>): void {\n    this.values[outerIndex] = innerValue;\n    if (!(innerSub as any)._hasValue) {\n      (innerSub as any)._hasValue = true;\n      this.haveValues++;\n    }\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, T>): void {\n    const { destination, haveValues, values } = this;\n    const len = values.length;\n\n    if (!(innerSub as any)._hasValue) {\n      destination.complete();\n      return;\n    }\n\n    this.completed++;\n\n    if (this.completed !== len) {\n      return;\n    }\n\n    if (haveValues === len) {\n      destination.next(values);\n    }\n\n    destination.complete();\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { PosixService } from './posix.service';\nimport { DataService } from './data.service';\nimport { CronJobsFrequency, CronJobsSelectOption } from '../contracts/contracts';\nexport class QuartzService extends PosixService {\n/**\n * @param {?} dataService\n */\nconstructor(protected dataService: DataService) {\n    super(dataService);\n  }\n/**\n * @return {?}\n */\nprotected getDaysOfWeek(): Array<CronJobsSelectOption> {\n    return this.dataService.getDaysOfWeek(true);\n  }\n/**\n * @param {?} value\n * @return {?}\n */\npublic fromCronWithDefault(value: String): CronJobsFrequency {\n    const /** @type {?} */ cron = value.trim().replace(/\\s+/g, ' ').split(' ');\n    const /** @type {?} */ frequency = this.getDefaultFrequenceWithDefault();\n\n    return this.fromCronQuartzInternal(cron, frequency);\n  }\n/**\n * @param {?} value\n * @return {?}\n */\npublic fromCron(value: String): CronJobsFrequency {\n    const /** @type {?} */ cron = value.trim().replace(/\\s+/g, ' ').split(' ');\n    const /** @type {?} */ frequency = this.getDefaultFrequency();\n    return this.fromCronQuartzInternal(cron, frequency);\n  }\n/**\n * @param {?} cron\n * @param {?} frequency\n * @return {?}\n */\nprivate fromCronQuartzInternal(cron: string[], frequency: CronJobsFrequency) {\n    if (!(cron.length === 6 || cron.length === 7)) {\n      return frequency;\n    }\n\n    if (cron[1] === '*' && cron[2] === '*' && cron[3] === '*' && cron[4] === '*' && cron[5] === '?') {\n      frequency.baseFrequency = this.baseFrequency.minute; // every minute\n    } else if (cron[2] === '*' && cron[3] === '*' && cron[4] === '*' && cron[5] === '?') {\n      frequency.baseFrequency = this.baseFrequency.hour; // every hour\n    } else if (cron[3] === '*' && cron[4] === '*' && cron[5] === '?') {\n      frequency.baseFrequency = this.baseFrequency.day; // every day\n    } else if (cron[3] === '?' && cron[4] === '*') {\n      frequency.baseFrequency = this.baseFrequency.week; // every week\n    } else if (cron[4] === '*' && cron[5] === '?') {\n      frequency.baseFrequency = this.baseFrequency.month; // every month\n    } else if (cron[5] === '?') {\n      frequency.baseFrequency = this.baseFrequency.year; // every year\n    }\n    if (cron[1] !== '*') {\n      // preparing to handle multiple minutes\n      frequency.minutes = this.getValueArray(cron[1]);\n    }\n    if (cron[2] !== '*') {\n      // preparing to handle multiple hours\n      frequency.hours = this.getValueArray(cron[2]);\n    }\n    if (cron[3] !== '*' && cron[3] !== '?') {\n      // preparing to handle multiple days of the month\n      frequency.daysOfMonth = this.getValueArray(cron[3]);\n    }\n    if (cron[4] !== '*') {\n      // preparing to handle multiple months\n      frequency.months = this.getValueArray(cron[4]);\n    }\n    if (cron[5] !== '*' && cron[5] !== '?') {\n      // preparing to handle multiple days of the week\n      frequency.daysOfWeek = this.getValueArray(cron[5]);\n    }\n    return frequency;\n  }\n/**\n * @param {?} newValue\n * @return {?}\n */\nsetCron(newValue: CronJobsFrequency) {\n    const /** @type {?} */ cron = ['0', '*', '*', '*', '*', '?'];\n\n    if (newValue && newValue.baseFrequency) {\n      if (newValue.baseFrequency >= this.baseFrequency.hour) {\n        cron[1] = newValue.minutes.length > 0 ? newValue.minutes.join(',') : '*';\n      }\n\n      if (newValue.baseFrequency >= this.baseFrequency.day) {\n        cron[2] = newValue.hours.length > 0 ? newValue.hours.join(',') : '*';\n      }\n\n      if (newValue.baseFrequency === this.baseFrequency.week) {\n        cron[3] = '?';\n        cron[5] = newValue.daysOfWeek.length > 0 ? newValue.daysOfWeek.join(',') : '*';\n      }\n\n      if (newValue.baseFrequency >= this.baseFrequency.month) {\n        cron[3] = newValue.daysOfMonth.length > 0 ? newValue.daysOfMonth.join(',') : '*';\n      }\n\n      if (newValue.baseFrequency === this.baseFrequency.year) {\n        cron[4] = newValue.months.length > 0 ? newValue.months.join(',') : '*';\n      }\n    } else {\n      return '';\n    }\n\n    return cron.join(' ');\n  }\n\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: DataService, },\n];\n}\n\nfunction QuartzService_tsickle_Closure_declarations() {\n/** @type {?} */\nQuartzService.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nQuartzService.ctorParameters;\n/** @type {?} */\nQuartzService.prototype.dataService;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","\nimport {filter, takeUntil, map, publishReplay, refCount} from 'rxjs/operators';\nimport {\n  Component, forwardRef, Injector, Input, OnChanges, OnDestroy, OnInit,\n  SimpleChanges\n} from '@angular/core';\nimport {\n  CronJobsConfig, CronJobsFrequency, CronJobsSelectOption,\n  CronJobsValidationConfig,\n  OptionType\n} from '../contracts/contracts';\nimport { DataService } from '../services/data.service';\nimport { ControlValueAccessor, FormBuilder, FormControl, FormGroup, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { Subject ,  Observable } from 'rxjs';\n\n\n\n\n\nimport { PosixService } from '../services/posix.service';\nimport { QuartzService } from '../services/quartz.service';\nexport class CronJobsComponent implements OnInit, OnChanges, OnDestroy, ControlValueAccessor {\n   config: CronJobsConfig;\n   validate: CronJobsValidationConfig;\n   isValid = true;\n   formControl: FormControl;\npublic isDisabled = false;\npublic baseFrequencyData: Array<CronJobsSelectOption>;\npublic baseFrequency$: Observable<number>;\npublic daysOfWeekData: Array<CronJobsSelectOption> = [];\npublic daysOfMonthData: Array<CronJobsSelectOption> = [];\npublic monthsData: Array<CronJobsSelectOption> = [];\npublic hoursData: Array<CronJobsSelectOption> = [];\npublic minutesData: Array<CronJobsSelectOption> = [];\npublic onChange: (cronValue: string) => {};\npublic onTouched: () => {};\npublic cronJobsForm: FormGroup;\nprivate isPatching = false;\nprivate unSubscribe = new Subject();\nprivate cronService: PosixService;\n/**\n * @param {?} dataService\n * @param {?} injector\n * @param {?} formBuilder\n */\nconstructor(private dataService: DataService,\nprivate injector: Injector,\nprivate formBuilder: FormBuilder) {\n\n    this.cronJobsForm = this.formBuilder.group({\n      baseFrequency: 0,\n      daysOfWeek: '',\n      daysOfMonth: '',\n      months: '',\n      hours: '',\n      minutes: ''\n    });\n\n    this.config = this.dataService.getConfig();\n    this.validate = this.dataService.getValidate();\n    this.setService();\n  }\n/**\n * @return {?}\n */\nngOnInit() {\n    this.baseFrequency$ = this.cronJobsForm.get('baseFrequency')\n      .valueChanges.pipe(\n      takeUntil(this.unSubscribe),\n      map(v => +v),\n      publishReplay(1),\n      refCount(), );\n\n    this.cronJobsForm\n      .valueChanges.pipe(\n      takeUntil(this.unSubscribe),\n      filter(() => !this.isPatching),\n      map((freq: CronJobsFrequency) => {\n        freq.baseFrequency = +freq.baseFrequency;\n        return freq;\n      }), )\n      .subscribe((values: CronJobsFrequency) => {\n        if (!values.baseFrequency) {\n          values = this.cronService.getDefaultFrequenceWithDefault();\n          this.cronJobsForm.patchValue(values, { emitEvent: false });\n        }\n        this.onChange(this.cronService.setCron(values));\n      });\n\n    let /** @type {?} */ baseFreq = this.dataService.baseFrequency;\n\n    if (this.config.option) {\n      baseFreq = baseFreq.filter(x => !(this.config.option.hasOwnProperty(OptionType[x.type])\n        && !this.config.option[OptionType[x.type]])\n      );\n    }\n\n    this.baseFrequencyData = baseFreq;\n    this.daysOfMonthData = this.dataService.daysOfMonth;\n    this.daysOfWeekData = this.dataService.getDaysOfWeek(false);\n    this.monthsData = this.dataService.months;\n    this.hoursData = this.dataService.hours;\n    this.minutesData = this.dataService.minutes;\n\n    this.isPatching = true;\n    setTimeout(() => {\n      this.cronJobsForm.patchValue(this.cronService.getDefaultFrequenceWithDefault());\n      this.isPatching = false;\n    });\n  }\n/**\n * @return {?}\n */\nonBlur() {\n    this.onTouched();\n  }\n/**\n * @param {?} changes\n * @return {?}\n */\nngOnChanges(changes: SimpleChanges) {\n    if (changes['config']) {\n      this.config = this.dataService.getConfig( /** @type {?} */((<CronJobsConfig>changes['config'].currentValue)));\n      setTimeout(() => {\n        if (!changes['config'].previousValue ||\n          changes['config'].previousValue['quartz'] !== changes['config'].currentValue['quartz']) {\n          this.daysOfWeekData = this.dataService.getDaysOfWeek(this.config.quartz);\n          this.cronJobsForm.patchValue({ daysOfWeek: this.daysOfWeekData[0].value });\n        }\n      });\n      this.setService();\n    }\n\n    if (changes['validate']) {\n      this.validate = this.dataService.getValidate( /** @type {?} */((<CronJobsValidationConfig>changes['validate'].currentValue)));\n    }\n  }\n/**\n * @return {?}\n */\nsetService() {\n    if (this.config.quartz) {\n      this.cronService = this.injector.get(QuartzService);\n    } else {\n      this.cronService = this.injector.get(PosixService);\n    }\n  }\n/**\n * @param {?} cronValue\n * @return {?}\n */\nwriteValue(cronValue: string): void {\n    this.isPatching = true;\n    let /** @type {?} */ valueToPatch: CronJobsFrequency;\n    if (cronValue) {\n      valueToPatch = this.cronService.fromCronWithDefault(cronValue);\n    } else {\n      valueToPatch = this.cronService.getDefaultFrequenceWithDefault();\n    }\n\n    setTimeout(() => {\n      this.cronJobsForm.patchValue(valueToPatch);\n      this.isPatching = false;\n    });\n  }\n/**\n * @param {?} fn\n * @return {?}\n */\nregisterOnChange(fn: any): void {\n    this.onChange = fn;\n  }\n/**\n * @param {?} fn\n * @return {?}\n */\nregisterOnTouched(fn: any): void {\n    this.onTouched = fn;\n  }\n/**\n * @param {?} isDisabled\n * @return {?}\n */\nsetDisabledState?(isDisabled: boolean): void {\n    this.isDisabled = isDisabled;\n    if (this.isDisabled) {\n      this.cronJobsForm.disable();\n    } else {\n      this.cronJobsForm.enable();\n    }\n  }\n/**\n * @return {?}\n */\ngetIsValid(): boolean {\n    return this.validate.validate ? this.getValid() : false;\n  }\n/**\n * @return {?}\n */\ngetIsInvalid(): boolean {\n    return this.validate.validate ? !this.getValid() : false;\n  }\n/**\n * @return {?}\n */\ngetValid(): boolean {\n    return this.formControl ? this.formControl.valid : this.isValid;\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    this.unSubscribe.next();\n    this.unSubscribe.complete();\n  }\n\nstatic decorators: DecoratorInvocation[] = [\n{ type: Component, args: [{\n  selector: 'cron-jobs',\n  template: `\n    <div class=\"form-inline\" *ngIf=\"config?.bootstrap\" [formGroup]=\"cronJobsForm\">\n      <label class=\"mr-sm-2\" for=\"selectBase\">Every: </label>\n      <select class=\"form-control\" id=\"selectBase\" (blur)=\"onBlur()\"\n              [ngClass]=\"{'is-valid': getIsValid(), 'is-invalid': getIsInvalid()}\"\n              formControlName=\"baseFrequency\">\n        <option *ngFor=\"let item of baseFrequencyData\" [value]=\"item.value\">{{item.label}}</option>\n      </select>\n      <label class=\"mx-sm-2\" *ngIf=\"(baseFrequency$ | async) === 4\">on</label>\n      <select multiple [multiple]=\"config.multiple\" class=\"form-control\" (blur)=\"onBlur()\"\n              [ngClass]=\"{'is-valid': getIsValid(), 'is-invalid': getIsInvalid()}\"\n              *ngIf=\"(baseFrequency$ | async) === 4\" formControlName=\"daysOfWeek\">\n        <option *ngFor=\"let item of daysOfWeekData\" [value]=\"item.value\">{{item.label}}</option>\n      </select>\n      <label class=\"mx-sm-2\" *ngIf=\"(baseFrequency$ | async) >= 5\">on the</label>\n      <select multiple [multiple]=\"config.multiple\" class=\"form-control\" (blur)=\"onBlur()\"\n              [ngClass]=\"{'is-valid': getIsValid(), 'is-invalid': getIsInvalid()}\"\n              *ngIf=\"(baseFrequency$ | async) >= 5\" formControlName=\"daysOfMonth\">\n        <option *ngFor=\"let item of daysOfMonthData\" [value]=\"item.value\">{{item.label}}</option>\n      </select>\n      <label class=\"mx-sm-2\" *ngIf=\"(baseFrequency$ | async) === 6\">of</label>\n      <select multiple [multiple]=\"config.multiple\" class=\"form-control\" (blur)=\"onBlur()\"\n              [ngClass]=\"{'is-valid': getIsValid(), 'is-invalid': getIsInvalid()}\"\n              *ngIf=\"(baseFrequency$ | async) === 6\" formControlName=\"months\">\n        <option *ngFor=\"let item of monthsData\" [ngValue]=\"item.value\">{{item.label}}</option>\n      </select>\n      <label class=\"mx-sm-2\" *ngIf=\"(baseFrequency$ | async) >= 2\">at</label>\n      <select multiple [multiple]=\"config.multiple\" class=\"form-control\" (blur)=\"onBlur()\"\n              [ngClass]=\"{'is-valid': getIsValid(), 'is-invalid': getIsInvalid()}\"\n              *ngIf=\"(baseFrequency$ | async) >= 3\" formControlName=\"hours\">\n        <option *ngFor=\"let item of hoursData\" [value]=\"item.value\">{{item.label}}</option>\n      </select>\n      <label class=\"mx-sm-2\" *ngIf=\"(baseFrequency$ | async) >= 3 \">:</label>\n      <select multiple [multiple]=\"config.multiple\" class=\"form-control\" (blur)=\"onBlur()\"\n              [ngClass]=\"{'is-valid': getIsValid(), 'is-invalid': getIsInvalid()}\"\n              *ngIf=\"(baseFrequency$ | async) >=2\" formControlName=\"minutes\">\n        <option *ngFor=\"let item of minutesData\" [value]=\"item.value\">{{item.label}}</option>\n      </select>\n      <label class=\"mx-sm-2\" *ngIf=\"(baseFrequency$ | async) === 2\">past the hour</label>\n    </div>\n    <div class=\"cron-wrap\" *ngIf=\"!config?.bootstrap\" [formGroup]=\"cronJobsForm\">\n      <span>Every: </span>\n      <div class=\"cron-select-wrap\">\n        <select class=\"cron-select\" formControlName=\"baseFrequency\" (blur)=\"onBlur()\"\n                [ngClass]=\"{'is-valid': getIsValid(), 'is-invalid': getIsInvalid()}\">\n          <option *ngFor=\"let item of baseFrequencyData\" [value]=\"item.value\">{{item.label}}</option>\n        </select>\n      </div>\n      <div class=\"select-options\">\n        <span  *ngIf=\"(baseFrequency$ | async) === 4\">on </span>\n        <div *ngIf=\"(baseFrequency$ | async) === 4\" class=\"cron-select-wrap\">\n          <select multiple [multiple]=\"config.multiple\" class=\"cron-select day-of-week-value\" (blur)=\"onBlur()\"\n                  [ngClass]=\"{'is-valid': getIsValid(), 'is-invalid': getIsInvalid()}\"\n                  formControlName=\"daysOfWeek\">\n            <option *ngFor=\"let item of daysOfWeekData\" [value]=\"item.value\">{{item.label}}</option>\n          </select>\n        </div>\n        <span *ngIf=\"(baseFrequency$ | async) >= 5\">on the </span>\n        <div *ngIf=\"(baseFrequency$ | async) >= 5\" class=\"cron-select-wrap\">\n          <select multiple [multiple]=\"config.multiple\" class=\"cron-select day-of-month-value\" (blur)=\"onBlur()\"\n                  [ngClass]=\"{'is-valid': getIsValid(), 'is-invalid': getIsInvalid()}\"\n                  formControlName=\"daysOfMonth\">\n            <option *ngFor=\"let item of daysOfMonthData\" [value]=\"item.value\">{{item.label}}</option>\n          </select>\n        </div>\n        <span *ngIf=\"(baseFrequency$ | async) === 6\">of </span>\n        <div *ngIf=\"(baseFrequency$ | async) === 6\" class=\"cron-select-wrap\">\n          <select multiple [multiple]=\"config.multiple\" class=\"cron-select month-value\" (blur)=\"onBlur()\"\n                  [ngClass]=\"{'is-valid': getIsValid(), 'is-invalid': getIsInvalid()}\"\n                  formControlName=\"months\">\n            <option *ngFor=\"let item of monthsData\" [ngValue]=\"item.value\">{{item.label}}</option>\n          </select>\n        </div>\n        <span *ngIf=\"(baseFrequency$ | async) >= 3 \">at </span>\n        <div *ngIf=\"(baseFrequency$ | async) >= 3\" class=\"cron-select-wrap\">\n          <select multiple [multiple]=\"config.multiple\" class=\"cron-select hour-value\" (blur)=\"onBlur()\"\n                  [ngClass]=\"{'is-valid': getIsValid(), 'is-invalid': getIsInvalid()}\"\n                  formControlName=\"hours\">\n            <option *ngFor=\"let item of hoursData\" [value]=\"item.value\">{{item.label}}</option>\n          </select>\n        </div>\n        <span *ngIf=\"(baseFrequency$ | async) >= 3\"> : </span>\n        <div *ngIf=\"(baseFrequency$ | async) >=2\" class=\"cron-select-wrap\">\n          <select multiple [multiple]=\"config.multiple\" class=\"cron-select minute-value\" (blur)=\"onBlur()\"\n                  [ngClass]=\"{'is-valid': getIsValid(), 'is-invalid': getIsInvalid()}\"\n                  formControlName=\"minutes\">\n            <option *ngFor=\"let item of minutesData\" [value]=\"item.value\">{{item.label}}</option>\n          </select>\n        </div>\n        <span *ngIf=\"(baseFrequency$ | async) === 2\"> past the hour</span>\n      </div>\n    </div>\n  `,\n  styles: [`\n    :host {\n      display: block;\n    }\n\n    .cron-select-wrap {\n      display: inline-block;\n    }\n\n    .cron-select-wrap .cron-select {\n      width: 150px;\n      height: 34px;\n      padding: 6px 12px;\n      margin: 0;\n      font-size: 14px;\n      line-height: 1.42857143;\n      color: #555;\n      background: #fff none;\n      border: 1px solid #ccc;\n      border-radius: 4px;\n      -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);\n      box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);\n      -webkit-transition: border-color ease-in-out 0.15s, -webkit-box-shadow ease-in-out 0.15s;\n      transition: border-color ease-in-out 0.15s, -webkit-box-shadow ease-in-out 0.15s;\n      transition: border-color ease-in-out 0.15s, box-shadow ease-in-out 0.15s;\n      transition: border-color ease-in-out 0.15s, box-shadow ease-in-out 0.15s, -webkit-box-shadow ease-in-out 0.15s;\n    }\n\n    .cron-select-wrap select[multiple] {\n      height: 140px;\n    }\n\n    .select-options {\n      display: inline-block;\n    }\n  `],\n  providers: [\n    PosixService,\n    QuartzService,\n    DataService,\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => CronJobsComponent),\n      multi: true\n    }\n  ]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: DataService, },\n{type: Injector, },\n{type: FormBuilder, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'config': [{ type: Input },],\n'validate': [{ type: Input },],\n'isValid': [{ type: Input },],\n'formControl': [{ type: Input },],\n};\n}\n\nfunction CronJobsComponent_tsickle_Closure_declarations() {\n/** @type {?} */\nCronJobsComponent.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nCronJobsComponent.ctorParameters;\n/** @type {?} */\nCronJobsComponent.propDecorators;\n/** @type {?} */\nCronJobsComponent.prototype.config;\n/** @type {?} */\nCronJobsComponent.prototype.validate;\n/** @type {?} */\nCronJobsComponent.prototype.isValid;\n/** @type {?} */\nCronJobsComponent.prototype.formControl;\n/** @type {?} */\nCronJobsComponent.prototype.isDisabled;\n/** @type {?} */\nCronJobsComponent.prototype.baseFrequencyData;\n/** @type {?} */\nCronJobsComponent.prototype.baseFrequency$;\n/** @type {?} */\nCronJobsComponent.prototype.daysOfWeekData;\n/** @type {?} */\nCronJobsComponent.prototype.daysOfMonthData;\n/** @type {?} */\nCronJobsComponent.prototype.monthsData;\n/** @type {?} */\nCronJobsComponent.prototype.hoursData;\n/** @type {?} */\nCronJobsComponent.prototype.minutesData;\n/** @type {?} */\nCronJobsComponent.prototype.onChange;\n/** @type {?} */\nCronJobsComponent.prototype.onTouched;\n/** @type {?} */\nCronJobsComponent.prototype.cronJobsForm;\n/** @type {?} */\nCronJobsComponent.prototype.isPatching;\n/** @type {?} */\nCronJobsComponent.prototype.unSubscribe;\n/** @type {?} */\nCronJobsComponent.prototype.cronService;\n/** @type {?} */\nCronJobsComponent.prototype.dataService;\n/** @type {?} */\nCronJobsComponent.prototype.injector;\n/** @type {?} */\nCronJobsComponent.prototype.formBuilder;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { CronJobsComponent } from './cron-jobs/cron-jobs.component';\nimport { DataService } from './services/data.service';\nimport { PosixService } from './services/posix.service';\nimport { QuartzService } from './services/quartz.service';\nexport class CronJobsModule {\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  imports: [\n    CommonModule,\n    FormsModule,\n    ReactiveFormsModule,\n  ],\n  declarations: [\n    CronJobsComponent\n  ],\n  exports: [\n    CronJobsComponent\n  ],\n  providers: [\n    DataService,\n    PosixService,\n    QuartzService\n  ]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction CronJobsModule_tsickle_Closure_declarations() {\n/** @type {?} */\nCronJobsModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nCronJobsModule.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"],"names":["__extends","d","b","__","this","constructor","extendStatics","prototype","Object","create","tryCatcher","tryCatchTarget","apply","arguments","e","errorObject","tryCatch","fn","isFunction","x","hostReportError","err","setTimeout","isObject","flattenUnsubscriptionErrors","errors","reduce","errs","concat","UnsubscriptionError","isTrustedSubscriber","obj","Subscriber","rxSubscriberSymbol","getPromiseCtor","promiseCtor","config","Promise","Error","subscribeToResult","outerSubscriber","result","outerValue","outerIndex","destination","InnerSubscriber","subscribeTo","dispatchBufferTimeSpanOnly","state","subscriber","prevContext","context","closeContext","closed","openContext","closeAction","schedule","bufferTimeSpan","dispatchBufferCreation","bufferCreationInterval","scheduler","add","dispatchBufferClose","arg","fromArray","input","Observable","sub","Subscription","i","length","next","complete","subscribeToArray","empty$1","emptyScheduled","EMPTY","of","args","_i","value","isScheduler","undefined","pop","empty","_isScalar","scalar","map","project","thisArg","source","TypeError","lift","MapOperator","dispatch$1","_a","error","refCount","RefCountOperator","publishReplay","bufferSize","windowTime","selectorOrScheduler","selector","subject","ReplaySubject","subjectOrSubjectFactory","subjectFactory","MulticastOperator","connectable","connectableObservableDescriptor","multicast","dispatchNotification","period","takeUntil","notifier","TakeUntilOperator","dispatchWindowTimeSpanOnly","windowTimeSpan","window","closeWindow","openWindow","dispatchWindowCreation","windowCreationInterval","action","subscription","timeSpanState","dispatchWindowClose","remove","setPrototypeOf","__proto__","Array","p","hasOwnProperty","_enable_super_gross_mode_that_will_cause_bad_things","useDeprecatedSynchronousErrorHandling","stack","_super","_this","call","toString","join","name","tslib_1.__extends","unsubscribe","_parent","_parents","_subscriptions","_unsubscribe","hasErrors","index","len","trial","isArray","push","teardown","_addParent","tmp","subscriptions","subscriptionIndex","indexOf","splice","parent","rxSubscriber","Symbol","for","destinationOrNext","syncErrorValue","syncErrorThrown","syncErrorThrowable","isStopped","emptyObserver","trustedSubscriber","SafeSubscriber","_next","_error","_complete","_unsubscribeAndRecycle","_parentSubscriber","observerOrNext","bind","_context","__tryOrSetError","__tryOrUnsub","wrappedComplete","OuterSubscriber","notifyNext","innerValue","innerIndex","innerSub","notifyError","notifyComplete","subscribe","_subscribe","operator","observable","sink","nextOrObserver","toSubscriber","_trySubscribe","forEach","resolve","reject","Symbol_observable","pipe","operations","fns","prev","noop","pipeFromArray","toPromise","array","iterator","obs","subscribeToObservable","isArrayLike","then","isPromise","promise","subscribeToPromise","Symbol_iterator","iterable","item","done","return","subscribeToIterable","msg","AsyncAction","AuditSubscriber","durationSelector","hasValue","throttled","duration","innerSubscription","clearThrottle","work","delay","id","recycleAsyncId","pending","requestAsyncId","setInterval","flush","clearInterval","execute","_execute","errored","errorValue","actions","Action","Scheduler","SchedulerAction","now","AsyncScheduler","delegate","active","scheduled","shift","Context","BufferSubscriber","closingNotifier","buffer","BufferCountSubscriber","BufferSkipCountSubscriber","startBufferEvery","buffers","count","NONE","BufferTimeSubscriber","maxBufferSize","contexts","timespanOnly","timeSpanOnlyState","closeState","creationState","filledBufferContext","context_1","onBufferFull","context_2","BufferToggleSubscriber","openings","closingSelector","closeBuffer","openBuffer","trySubscribe","BufferWhenSubscriber","subscribing","closingSubscription","CatchSubscriber","caught","err2","CombineLatestSubscriber","resultSelector","values","observables","toRespond","unused","oldVal","_tryResultSelector","slice","MapSubscriber","Notification","MergeMapSubscriber","concurrent","Number","POSITIVE_INFINITY","hasCompleted","_tryNext","_innerSub","ish","CountSubscriber","predicate","_tryPredicate","DebounceSubscriber","emitValue","durationSubscription","DebounceTimeSubscriber","dueTime","lastValue","clearDebounce","debouncedSubscription","dispatchNext","debouncedNext","DefaultIfEmptySubscriber","defaultValue","isEmpty","kind","observe","observer","do","accept","toObservable","dispatch","throwError","createNext","undefinedValueNotification","createError","createComplete","completeNotification","DelayMessage","DelaySubscriber","queue","time","notification","delay_1","Math","max","_schedule","scheduleNotification","message","SubscriptionDelaySubscriber","DelayWhenSubscriber","delayDurationSelector","completed","removeSubscription","tryComplete","delayNotifier","tryDelay","subscriptionIdx","delayNotifierSubscriptions","notifierSubscription","SubscriptionDelayObservable","subscriptionDelay","subscribeToSource","sourceSubscribed","FilterOperator","DeMaterializeSubscriber","DistinctSubscriber","keySelector","flushes","Set","clear","_useKeySelector","_finalizeNext","key","has","DistinctUntilChangedSubscriber","compare","hasKey","y","Boolean","ArgumentOutOfRangeError","FilterSubscriber","EmptyError","TapSubscriber","_tapNext","_tapError","_tapComplete","ObjectUnsubscribedError","TakeSubscriber","total","EverySubscriber","everyValueMatch","SwitchFirstSubscriber","hasSubscription","ExhaustMapSubscriber","tryNext","ExpandSubscriber","subscribeToProjection","FinallySubscriber","callback","FindValueSubscriber","yieldIndex","SubjectSubscription","observers","subscriberIndex","SubjectSubscriber","Subject","hasError","AnonymousSubject","copy","thrownError","asObservable","GroupDurationSubscriber","GroupBySubscriber","elementSelector","subjectSelector","groups","attemptedToUnsubscribe","_group","Map","element","group","get","set","groupedObservable","GroupedObservable","removeGroup","delete","groupSubject","refCountSubscription","InnerRefCountSubscription","IgnoreElementsSubscriber","IsEmptySubscriber","TakeLastSubscriber","ring","idx","MapToSubscriber","MaterializeSubscriber","ScanSubscriber","accumulator","_seed","hasSeed","defineProperty","enumerable","configurable","seed","MergeScanSubscriber","acc","_refCount","refCounter","RefCountSubscriber","connection","connect","sharedConnection","_connection","connectableProto","ConnectableObservable","getSubject","_subject","_isComplete","ConnectableSubscriber","higherOrderRefCount","writable","ObserveOnSubscriber","scheduleMessage","ObserveOnMessage","QueueAction","OnErrorResumeNextSubscriber","nextSources","subscribeToNextSource","PairwiseSubscriber","hasPrev","BehaviorSubject","_value","getValue","AsyncSubject","hasNext","QueueScheduler","_events","_infiniteTimeWindow","_bufferSize","_windowTime","nextTimeWindow","nextInfiniteTimeWindow","ReplayEvent","_getNow","_trimBufferThenGetEvents","eventsCount","spliceCount","SequenceEqualCompareToSubscriber","RaceSubscriber","hasFirst","RepeatSubscriber","RepeatWhenSubscriber","sourceIsBeingSubscribedTo","retries","subscribeToRetries","retriesSubscription","notifications","RetrySubscriber","RetryWhenSubscriber","SampleSubscriber","SampleTimeSubscriber","SequenceEqualSubscriber","compareTo","comparor","_b","_oneComplete","emit","checkValues","a","areEqual","nextB","nextHandle","SingleSubscriber","seenValue","applySingleValue","singleValue","SkipSubscriber","SkipLastSubscriber","_skipCount","_count","skipCount","_ring","currentIndex","oldValue","SkipUntilSubscriber","SkipWhileSubscriber","skipping","tryCallPredicate","tasksByHandle","Immediate","setImmediate","cb","handle","runIfPresent","clearImmediate","AsapAction","asap","AsapScheduler","SubscribeOnObservable","delayTime","val","parseFloat","isNumeric","SwitchMapSubscriber","takeUntilSubscriber","TakeUntilSubscriber","CountedSubject","TakeWhileSubscriber","nextOrComplete","predicateResult","ThrottleSubscriber","_leading","_trailing","_hasValue","_sendValue","_throttled","send","throttle","tryDurationSelector","throttlingDone","ThrottleTimeSubscriber","leading","trailing","_hasTrailingValue","_trailingValue","TimeoutError","TimeoutWithSubscriber","absoluteTimeout","waitFor","withObservable","scheduleTimeout","dispatchTimeout","WindowSubscriber","prevWindow","newWindow","WindowCountSubscriber","windowSize","startWindowEvery","windows","c","window_1","_numberOfNextedValues","StaticIterator","WindowTimeSubscriber","maxWindowSize","numberOfNextedValues","window_2","WindowToggleSubscriber","context_3","context_4","inner","openSubscription","unsubscribeClosingNotification","closingNotification","WithLatestFromSubscriber","found","_tryProject","ZipSubscriber","iterators","StaticArrayIterator","ZipBufferIterator","stillUnsubscribed","notifyInactive","checkIterators","shouldComplete","_tryresultSelector","nextResult","isComplete","OptionType","minute","hour","day","week","month","year","DataService","defaultConfig","quartz","bootstrap","multiple","defaultValidateConfig","validate","daysOfWeekPosix","label","daysOfWeekQuartz","numeral","_months","_baseFrequency","type","_hours","_minutes","getConfig","assign","getValidate","validateConfig","getDaysOfWeek","decorators","Injectable","ctorParameters","AnimationFrameAction","requestAnimationFrame","cancelAnimationFrame","VirtualAction","AnimationFrameScheduler","VirtualTimeScheduler","maxFrames","frame","frameTimeFactor","sort","sortActions","PosixService","ForkJoinSubscriber","sources","haveValues","dataService","frequencyData","baseFrequency","getDefaultFrequency","minutes","hours","daysOfMonth","daysOfWeek","months","getDefaultFrequenceWithDefault","cronJobsFrequency","fromCronWithDefault","cron","trim","replace","split","frequency","fromCronInternal","fromCron","getValueArray","setCron","ele","QuartzService","fromCronQuartzInternal","newValue","CronJobsComponent","injector","formBuilder","isValid","isDisabled","daysOfWeekData","daysOfMonthData","monthsData","hoursData","minutesData","isPatching","unSubscribe","cronJobsForm","setService","ngOnInit","baseFrequency$","valueChanges","v","filter","freq","cronService","patchValue","emitEvent","onChange","baseFreq","option","baseFrequencyData","onBlur","onTouched","ngOnChanges","changes","previousValue","currentValue","writeValue","cronValue","valueToPatch","registerOnChange","registerOnTouched","setDisabledState","disable","enable","getIsValid","getValid","getIsInvalid","formControl","valid","ngOnDestroy","Component","template","styles","providers","provide","NG_VALUE_ACCESSOR","useExisting","forwardRef","multi","Injector","FormBuilder","propDecorators","Input","CronJobsModule","NgModule","imports","CommonModule","FormsModule","ReactiveFormsModule","declarations","exports"],"mappings":"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"}
